{"/home/travis/build/npmtest/node-npmtest-couchbase/test.js":"/* istanbul instrument in package npmtest_couchbase */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-couchbase/lib.npmtest_couchbase.js":"/* istanbul instrument in package npmtest_couchbase */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_couchbase = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_couchbase = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-couchbase/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-couchbase && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_couchbase */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_couchbase\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_couchbase.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_couchbase.rollup.js'] =\n            local.assetsDict['/assets.npmtest_couchbase.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_couchbase.__dirname + '/lib.npmtest_couchbase.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/couchbase.js":"'use strict';\n\nvar binding = require('./binding');\nvar auth = require('./auth');\n\nmodule.exports.Cluster = require('./cluster');\nmodule.exports.BucketImpl = require('./bucket');\nmodule.exports.SpatialQuery = require('./spatialquery');\nmodule.exports.ViewQuery = require('./viewquery');\nmodule.exports.N1qlQuery = require('./n1qlquery');\nmodule.exports.CbasQuery = require('./cbasquery');\nmodule.exports.SearchQuery = require('./searchquery');\nmodule.exports.SearchFacet = require('./searchquery_facets');\nmodule.exports.MutationState = require('./mutationstate');\nmodule.exports.Mock = require('./mock/couchbase');\nmodule.exports.Error = binding.Error;\nmodule.exports.errors = require('./errors');\nmodule.exports.ClassicAuthenticator = auth.ClassicAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/binding.js":"'use strict';\n\nvar util = require('util');\nvar fs = require('fs');\n\n/**\n * Represents the C/C++ binding layer that the Node.js SDK is built upon.\n * This library handles all network I/O along with most configuration and\n * bootstrapping requirements.\n * @external CouchbaseBinding\n */\n/**\n * @name CouchbaseBinding._setErrorClass\n */\n/**\n * @class CouchbaseBinding.Error\n * @private\n * @ignore\n */\n/**\n * @class CouchbaseBinding.CouchbaseImpl\n * @private\n * @ignore\n */\n/** @name CouchbaseBinding.CouchbaseImpl#shutdown */\n/** @name CouchbaseBinding.CouchbaseImpl#control */\n/** @name CouchbaseBinding.CouchbaseImpl#connect */\n/** @name CouchbaseBinding.CouchbaseImpl#getViewNode */\n/** @name CouchbaseBinding.CouchbaseImpl#getMgmtNode */\n/** @name CouchbaseBinding.CouchbaseImpl#setConnectCallback */\n/** @name CouchbaseBinding.CouchbaseImpl#setTranscoder */\n/** @name CouchbaseBinding.CouchbaseImpl#lcbVersion */\n/** @name CouchbaseBinding.CouchbaseImpl#get */\n/** @name CouchbaseBinding.CouchbaseImpl#getReplica */\n/** @name CouchbaseBinding.CouchbaseImpl#touch */\n/** @name CouchbaseBinding.CouchbaseImpl#unlock */\n/** @name CouchbaseBinding.CouchbaseImpl#remove */\n/** @name CouchbaseBinding.CouchbaseImpl#store */\n/** @name CouchbaseBinding.CouchbaseImpl#arithmetic */\n/** @name CouchbaseBinding.CouchbaseImpl#durability */\n/** @name CouchbaseBinding.CouchbaseImpl#viewQuery */\n/** @name CouchbaseBinding.CouchbaseImpl#n1qlQuery */\n/** @name CouchbaseBinding.CouchbaseImpl#ftsQuery */\n/** @name CouchbaseBinding.CouchbaseImpl#lookupIn */\n/** @name CouchbaseBinding.CouchbaseImpl#mutateIn */\n/** @name CouchbaseBinding.CouchbaseImpl#_errorTest */\n/**\n * @namespace CouchbaseBinding.Constants\n * @ignore\n */\n/** @name CouchbaseBinding.Constants.CNTL_SET */\n/** @name CouchbaseBinding.Constants.CNTL_GET */\n/** @name CouchbaseBinding.Constants.CNTL_OP_TIMEOUT */\n/** @name CouchbaseBinding.Constants.CNTL_DURABILITY_INTERVAL */\n/** @name CouchbaseBinding.Constants.CNTL_DURABILITY_TIMEOUT */\n/** @name CouchbaseBinding.Constants.CNTL_HTTP_TIMEOUT */\n/** @name CouchbaseBinding.Constants.CNTL_VIEW_TIMEOUT */\n/** @name CouchbaseBinding.Constants.CNTL_RBUFSIZE */\n/** @name CouchbaseBinding.Constants.CNTL_WBUFSIZE */\n/** @name CouchbaseBinding.Constants.CNTL_CONFIGURATION_TIMEOUT */\n/** @name CouchbaseBinding.Constants.CNTL_VBMAP */\n/** @name CouchbaseBinding.Constants.CNTL_CONFIG_HTTP_NODES */\n/** @name CouchbaseBinding.Constants.CNTL_CONFIG_CCCP_NODES */\n/** @name CouchbaseBinding.Constants.CNTL_CHANGESET */\n/** @name CouchbaseBinding.Constants.CNTL_CONFIG_ALL_NODES */\n/** @name CouchbaseBinding.Constants.CNTL_CONFIGCACHE */\n/** @name CouchbaseBinding.Constants.CNTL_SSL_MODE */\n/** @name CouchbaseBinding.Constants.CNTL_SSL_CACERT */\n/** @name CouchbaseBinding.Constants.CNTL_RETRYMODE */\n/** @name CouchbaseBinding.Constants.CNTL_HTCONFIG_URLTYPE */\n/** @name CouchbaseBinding.Constants.CNTL_COMPRESSION_OPTS */\n/** @name CouchbaseBinding.Constants.CNTL_RDBALLOCFACTORY */\n/** @name CouchbaseBinding.Constants.CNTL_SYNCDESTROY */\n/** @name CouchbaseBinding.Constants.CNTL_CONLOGGER_LEVEL */\n/** @name CouchbaseBinding.Constants.CNTL_DETAILED_ERRCODES */\n/** @name CouchbaseBinding.Constants.CNTL_REINIT_DSN */\n/** @name CouchbaseBinding.Constants.CNTL_CONFDELAY_THRESH */\n/** @name CouchbaseBinding.Constants.CNTL_CONFIG_NODE_TIMEOUT */\n/** @name CouchbaseBinding.Constants.ADD */\n/** @name CouchbaseBinding.Constants.REPLACE */\n/** @name CouchbaseBinding.Constants.SET */\n/** @name CouchbaseBinding.Constants.APPEND */\n/** @name CouchbaseBinding.Constants.PREPEND */\n/** @name CouchbaseBinding.Constants.SUCCESS */\n/** @name CouchbaseBinding.Constants.AUTH_CONTINUE */\n/** @name CouchbaseBinding.Constants.AUTH_ERROR */\n/** @name CouchbaseBinding.Constants.DELTA_BADVAL */\n/** @name CouchbaseBinding.Constants.E2BIG */\n/** @name CouchbaseBinding.Constants.EBUSY */\n/** @name CouchbaseBinding.Constants.ENOMEM */\n/** @name CouchbaseBinding.Constants.ERANGE */\n/** @name CouchbaseBinding.Constants.ERROR */\n/** @name CouchbaseBinding.Constants.ETMPFAIL */\n/** @name CouchbaseBinding.Constants.EINVAL */\n/** @name CouchbaseBinding.Constants.CLIENT_ETMPFAIL */\n/** @name CouchbaseBinding.Constants.KEY_EEXISTS */\n/** @name CouchbaseBinding.Constants.KEY_ENOENT */\n/** @name CouchbaseBinding.Constants.DLOPEN_FAILED */\n/** @name CouchbaseBinding.Constants.DLSYM_FAILED */\n/** @name CouchbaseBinding.Constants.NETWORK_ERROR */\n/** @name CouchbaseBinding.Constants.NOT_MY_VBUCKET */\n/** @name CouchbaseBinding.Constants.NOT_STORED */\n/** @name CouchbaseBinding.Constants.NOT_SUPPORTED */\n/** @name CouchbaseBinding.Constants.UNKNOWN_COMMAND */\n/** @name CouchbaseBinding.Constants.UNKNOWN_HOST */\n/** @name CouchbaseBinding.Constants.PROTOCOL_ERROR */\n/** @name CouchbaseBinding.Constants.ETIMEDOUT */\n/** @name CouchbaseBinding.Constants.BUCKET_ENOENT */\n/** @name CouchbaseBinding.Constants.CLIENT_ENOMEM */\n/** @name CouchbaseBinding.Constants.CONNECT_ERROR */\n/** @name CouchbaseBinding.Constants.EBADHANDLE */\n/** @name CouchbaseBinding.Constants.SERVER_BUG */\n/** @name CouchbaseBinding.Constants.PLUGIN_VERSION_MISMATCH */\n/** @name CouchbaseBinding.Constants.INVALID_HOST_FORMAT */\n/** @name CouchbaseBinding.Constants.INVALID_CHAR */\n/** @name CouchbaseBinding.Constants.DURABILITY_ETOOMANY */\n/** @name CouchbaseBinding.Constants.DUPLICATE_COMMANDS */\n/** @name CouchbaseBinding.Constants.EINTERNAL */\n/** @name CouchbaseBinding.Constants.NO_MATCHING_SERVER */\n/** @name CouchbaseBinding.Constants.BAD_ENVIRONMENT */\n/** @name CouchbaseBinding.Constants.HTTP_TYPE_VIEW */\n/** @name CouchbaseBinding.Constants.HTTP_TYPE_MANAGEMENT */\n/** @name CouchbaseBinding.Constants.HTTP_METHOD_GET */\n/** @name CouchbaseBinding.Constants.HTTP_METHOD_POST */\n/** @name CouchbaseBinding.Constants.HTTP_METHOD_PUT */\n/** @name CouchbaseBinding.Constants.HTTP_METHOD_DELETE */\n/** @name CouchbaseBinding.Constants.SDCMD_GET */\n/** @name CouchbaseBinding.Constants.SDCMD_EXISTS */\n/** @name CouchbaseBinding.Constants.SDCMD_REPLACE */\n/** @name CouchbaseBinding.Constants.SDCMD_DICT_ADD */\n/** @name CouchbaseBinding.Constants.SDCMD_DICT_UPSERT */\n/** @name CouchbaseBinding.Constants.SDCMD_ARRAY_ADD_FIRST */\n/** @name CouchbaseBinding.Constants.SDCMD_ARRAY_ADD_LAST */\n/** @name CouchbaseBinding.Constants.SDCMD_ARRAY_ADD_UNIQUE */\n/** @name CouchbaseBinding.Constants.SDCMD_ARRAY_INSERT */\n/** @name CouchbaseBinding.Constants.SDCMD_REMOVE */\n/** @name CouchbaseBinding.Constants.SDCMD_COUNTER */\n\n/**\n * @type {CouchbaseBinding}\n * @ignore\n */\nvar couchnode = require('bindings')('couchbase_impl');\n\nfunction CouchbaseError(message) {\n  Error.call(this);\n  Error.captureStackTrace(this, CouchbaseError);\n  this.message = message;\n}\nutil.inherits(CouchbaseError, Error);\nCouchbaseError.prototype.name = 'CouchbaseError';\ncouchnode._setErrorClass(CouchbaseError);\ncouchnode.Error = CouchbaseError;\n\nmodule.exports = couchnode;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/auth.js":"'use strict';\n\n/**\n * Authenticator for using classic authentication.\n *\n * @param {Object.<string, string>} buckets\n *  Map of bucket names to passwords.\n * @param {string} [username]\n *  Cluster administration username.\n * @param {string} [password]\n *  Cluster administration password.\n * @constructor\n *\n * @since 2.2.3\n * @uncommitted\n */\nfunction ClassicAuthenticator(buckets, username, password) {\n  this.buckets = buckets;\n  this.username = username;\n  this.password = password;\n}\n\nmodule.exports.ClassicAuthenticator = ClassicAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/cluster.js":"'use strict';\n\nvar util = require('util');\nvar events = require('events');\nvar request = require('request');\n\nvar connstr = require('./connstr');\n\nvar Bucket = require('./bucket');\nvar ClusterManager = require('./clustermgr');\nvar N1qlQuery = require('./n1qlquery');\nvar SearchQuery = require('./searchquery');\nvar CbasQuery = require('./cbasquery');\n\nfunction _arrayRemove(arr, element) {\n  var newArray = [];\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] !== element) {\n      newArray.push(arr[i]);\n    }\n  }\n  return newArray;\n}\n\n/**\n * Represents a singular cluster containing your buckets.\n *\n * @param {string} [cnstr] The connection string for your cluster.\n * @param {Object} [options]\n *  @param {string} [options.certpath]\n *  The path to the certificate to use for SSL connections\n * @constructor\n *\n * @since 2.0.0\n * @committed\n */\nfunction Cluster(cnstr, options) {\n  this.dsnObj = connstr.parse(cnstr);\n  this.auther = null;\n  this.connectingBuckets = [];\n  this.connectedBuckets = [];\n  this.waitQueue = [];\n\n  this.cbasHosts = null;\n\n  // Copy passed options into the connection string\n  if (options instanceof Object) {\n    for (var i in options) {\n      if (options.hasOwnProperty(i)) {\n        this.dsnObj.options[i] = encodeURIComponent(options[i]);\n      }\n    }\n  }\n}\n\n/**\n * An event emitter allowing you to bind to various query result set\n * events.\n *\n * @constructor\n *\n * @private\n * @memberof Bucket\n * @extends events.EventEmitter\n *\n * @since 2.2.3\n * @uncommitted\n */\nfunction CbasQueryResponse() {\n}\nutil.inherits(CbasQueryResponse, events.EventEmitter);\nCluster.CbasQueryResponse = CbasQueryResponse;\n\n/**\n * Invokes an operation and dispatches a callback error if one occurs.\n *\n * @param {Function} fn The operation callback to invoke.\n * @param {Array.<*>} args An array of arguments to pass to the function.\n *\n * @private\n * @ignore\n */\nCluster.prototype._invoke = function(fn, args) {\n  try {\n    fn.apply(this._cb, args);\n  } catch(e) {\n    args[args.length-1](e, null);\n  }\n};\n\n/**\n * Will either invoke the binding method specified by fn, or alternatively\n * push the operation to a queue which is flushed once a connection\n * has been established or failed.\n *\n * @param {Function} fn The binding method to invoke.\n * @param {Array} args A list of arguments for the method.\n *\n * @private\n * @ignore\n */\nCluster.prototype._maybeInvoke = function(fn, args) {\n  if (this.connected === true) {\n    this._invoke(fn, args);\n  } else if (this.connected === false) {\n    throw new Error('cannot perform operations on a shutdown bucket');\n  } else {\n    this.waitQueue.push([fn, args]);\n  }\n};\n\nCluster.prototype.enableCbas = function(hosts) {\n  if (!Array.isArray(hosts)) {\n    hosts = [hosts];\n  }\n\n  this.cbasHosts = hosts;\n};\n\n/**\n * Specifies an authenticator to use to authenticate to this cluster.\n *\n * @param {Authenticator|Object} auther\n *\n * @since 2.1.7\n * @uncommitted\n */\nCluster.prototype.authenticate = function(auther) {\n  this.auther = auther;\n};\n\n/**\n * Open a bucket to perform operations.  This will begin the handshake\n * process immediately and operations will complete later.  Subscribe to\n * the `connect` event to be alerted when the connection is ready, though\n * be aware operations can be successfully queued before this.\n *\n * @param {string} [name] The name of the bucket to open.\n * @param {string} [password] Password for the bucket.\n * @param {Function} [callback]\n * Callback to invoke on connection success or failure.\n * @returns {Bucket}\n *\n * @since 2.0.0\n * @committed\n */\nCluster.prototype.openBucket = function(name, password, callback) {\n  if (password instanceof Function) {\n    callback = arguments[1];\n    password = '';\n  }\n\n  var bucketDsnObj = connstr.normalize(this.dsnObj);\n  bucketDsnObj.bucket = name;\n  if (this.auther instanceof Object && this.auther.buckets instanceof Object) {\n    var bucketCreds = [];\n    for (var i in this.auther.buckets) {\n      if (this.auther.buckets.hasOwnProperty(i)) {\n        bucketCreds.push(JSON.stringify([i, this.auther.buckets[i]]));\n      }\n    }\n    if (bucketCreds.length > 0) {\n      bucketDsnObj.options.bucket_cred = bucketCreds;\n    }\n  }\n  bucketDsnObj.options.client_string =\n      'couchnode/' + require('../package.json').version;\n  this.dsnObj = bucketDsnObj;\n\n  var bucket = new Bucket({\n    dsnObj: bucketDsnObj,\n    username: name,\n    password: password\n  });\n  if (callback) {\n    bucket.on('connect', callback);\n    bucket.on('error', callback);\n  }\n\n  var self = this;\n  this.connectingBuckets.push(bucket);\n  bucket.on('connect', function() {\n    self.connectingBuckets = _arrayRemove(self.connectingBuckets, bucket);\n    self.connectedBuckets.push(bucket);\n    for (var i = 0; i < self.waitQueue.length; ++i) {\n      var itm = self.waitQueue[i];\n      self._invoke(itm[0], itm[1]);\n    }\n    self.waitQueue = [];\n  });\n  bucket.on('error', function() {\n    self.connectingBuckets = _arrayRemove(self.connectingBuckets, bucket);\n    if (self.connectingBuckets.length > 0) {\n      return;\n    }\n\n    var err = new Error('You cannot perform a cluster-level query without' +\n        ' at least one bucket open.');\n    for (var i = 0; i < self.waitQueue.length; ++i) {\n      var itm = self.waitQueue[i];\n      itm[1][itm[1].length-1](err, null);\n    }\n    self.waitQueue = [];\n  });\n\n  return bucket;\n};\n\nCluster.prototype._n1qlReq = function(host, q, adhoc, emitter) {\n  var bucket = this.connectedBuckets[0];\n  bucket._n1qlReq(host, q, adhoc, emitter);\n};\n\nCluster.prototype._n1ql = function(query, params, callback) {\n  var req = new Bucket.N1qlQueryResponse();\n\n  var invokeCb = callback;\n  if (!invokeCb) {\n    invokeCb = function(err) {\n      req.emit('error', err);\n    };\n  }\n\n  this._maybeInvoke(this._n1qlReq.bind(this),\n      [undefined, query.toObject(params), query.isAdhoc, req, invokeCb]);\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n\n  return req;\n};\n\nCluster.prototype._ftsReq = function(q, emitter) {\n  var bucket = this.connectedBuckets[0];\n  bucket._ftsReq(q, emitter);\n};\n\nCluster.prototype._fts = function(query, callback) {\n  var req = new Bucket.FtsQueryResponse();\n\n  var invokeCb = callback;\n  if (!invokeCb) {\n    invokeCb = function(err) {\n      req.emit('error', err);\n    };\n  }\n\n  this._maybeInvoke(this._ftsReq.bind(this),\n      [query, req, invokeCb]);\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n\n  return req;\n};\n\nCluster.prototype._cbasReq = function(host, q, emitter) {\n  var uri = 'http://' + host + '/query/service';\n\n  request({\n    method: 'post',\n    uri: uri,\n    body: q,\n    json: true\n  }, function (err, resp, body) {\n    if (err) {\n      emitter.emit('error', err);\n      return;\n    }\n\n    if (!body || body.status !== 'success') {\n      if (body && body.errors && body.errors.length > 0) {\n        var firstErr = body.errors[0];\n        err = new Error(firstErr.msg);\n        err.requestID = body.requestID;\n        err.code = firstErr.code;\n        err.otherErrors = [];\n\n        for (var i = 1; i < body.errors.length; ++i) {\n          var nextErr = body.errors[i];\n          var otherErr = new Error(nextErr.msg);\n          otherErr.code = nextErr.code;\n          err.otherErrors.push(otherErr);\n        }\n      } else {\n        err = new Error('An unknown CBAS error occured.' +\n            ' This is usually related to an out-of-memory condition.');\n      }\n\n      emitter.emit('error', err);\n      return;\n    }\n\n    // Emit each row\n    for (var j = 0; j < body.results.length; ++j) {\n      emitter.emit('row', body.results[j]);\n    }\n\n    // Emit all the rows, this is easy since we already have them\n    //  all, in the future with streaming we will need to copy N1QL.\n    emitter.emit('rows', body.results);\n\n    // Emit the end meta\n    delete body.results;\n    emitter.emit('end', body);\n  });\n};\n\nCluster.prototype._cbas = function(query, params, callback) {\n  if (!this.cbasHosts) {\n    throw new Error('You must use enableCbas to specify CBAS hosts.');\n  }\n  var host = this.cbasHosts[Math.floor(Math.random() * this.cbasHosts.length)];\n\n  var req = new Bucket.N1qlQueryResponse();\n\n  var self = this;\n  setImmediate(function() {\n    self._cbasReq(host, query.toObject(params), req);\n  });\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n\n  return req;\n};\n\n/**\n * Executes a previously prepared query object.  This could be a\n * {@link N1qlQuery}, {@link SearchQuery} or a {@link CbasQuery}.\n *\n * Note: You must have at least one bucket open (this is neccessary to\n * have cluster mapping information), and additionally be using the new\n * cluster-level authentication methods.\n *\n * Note: SearchQuery queries are currently an uncommitted interface and may be\n * subject to change in a future release.\n *\n * @param {N1qlQuery|SearchQuery|CbasQuery} query\n * The query to execute.\n * @param {Object|Array} [params]\n * A list or map to do replacements on a N1QL or CBAS query.\n * @param {Bucket.QueryCallback} callback\n * @returns {Bucket.N1qlQueryResponse|Bucket.FtsQueryResponse|\n *   Cluster.CbasQueryResponse}\n *\n * @since 2.1.7\n * @committed\n */\nCluster.prototype.query = function(query, params, callback) {\n  if (params instanceof Function) {\n    callback = arguments[1];\n    params = undefined;\n  }\n\n  if (query instanceof CbasQuery) {\n    return this._cbas(\n        query, params, callback);\n  }\n\n  if (!(this.auther instanceof Object)) {\n    var errC = new Error('You cannot perform a cluster-level query without' +\n        ' specifying credentials with Cluster.authenticate.');\n    setImmediate(function() {\n      if (callback) {\n        callback(errC);\n      }\n    });\n    return;\n  }\n\n  if (this.connectedBuckets.length === 0 &&\n      this.connectingBuckets.length === 0) {\n    var errB = new Error('You cannot perform a cluster-level query without' +\n        ' at least one bucket open.');\n    setImmediate(function() {\n      if (callback) {\n        callback(errB);\n      }\n    });\n    return;\n  }\n\n  if (query instanceof N1qlQuery) {\n    return this._n1ql(\n        query, params, callback\n    );\n  } else if (query instanceof SearchQuery) {\n    return this._fts(\n        query, callback\n    );\n  } else {\n    throw new TypeError(\n        'First argument needs to be a N1qlQuery.');\n  }\n};\n\n/**\n * Creates a manager allowing the management of a Couchbase cluster.\n *\n * @returns {ClusterManager}\n *\n * @since 2.0.0\n * @committed\n */\nCluster.prototype.manager = function(username, password) {\n  if (username === undefined && this.auther instanceof Object) {\n    username = this.auther.username;\n  }\n  if (password === undefined && this.auther instanceof Object) {\n    password = this.auther.password;\n  }\n  return new ClusterManager(this, username, password);\n};\n\nmodule.exports = Cluster;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/connstr.js":"'use strict';\n\nvar qs = require('querystring');\n\n/**\n * @class ConnStr.Spec\n * A container to hold information decoded from a couchbase connection\n * string.  It contains the scheme, hosts, bucket name and various KV\n * options that were attached to the string.\n *\n * @property {string} scheme\n * @property {Array.<Array.<string,number>>} hosts\n * @property {string} bucket\n * @property {Object} options\n *\n * @private\n * @ignore\n */\n\n/**\n * Static Constructor for Singleton object.  Not invokable.\n *\n * @constructor\n *\n * @private\n * @ignore\n */\nfunction ConnStr() {\n}\n\n/**\n * @param {ConnStrSpec} dsn\n * @returns {ConnStr.Spec}\n *\n * @private\n */\nConnStr.prototype._normalize = function(dsn) {\n  var dsnObj = {};\n\n  if (dsn.scheme) {\n    dsnObj.scheme = dsn.scheme;\n  } else {\n    dsnObj.scheme = 'http';\n  }\n\n  dsnObj.hosts = [];\n  if (dsn.hosts) {\n    if (typeof dsn.hosts === 'string') {\n      dsn.hosts = [dsn.hosts];\n    }\n\n    for (var i = 0; i < dsn.hosts.length; ++i) {\n      if (typeof dsn.hosts[i] === 'string') {\n        var portPos = dsn.hosts[i].indexOf(':');\n        if (portPos >= 0) {\n          var hostName = dsn.hosts[i].substr(0, portPos);\n          var portNum = parseInt(dsn.hosts[i].substr(portPos + 1), 10);\n          dsnObj.hosts.push([hostName, portNum]);\n        } else {\n          dsnObj.hosts.push([dsn.hosts[i], 0]);\n        }\n      } else {\n        dsnObj.hosts.push(dsn.hosts[i]);\n      }\n    }\n  }\n\n  if (dsn.bucket) {\n    dsnObj.bucket = dsn.bucket;\n  } else {\n    dsnObj.bucket = 'default';\n  }\n\n  if (dsn.options) {\n    dsnObj.options = dsn.options;\n  } else {\n    dsnObj.options = {};\n  }\n\n  return dsnObj;\n};\n\n/**\n * @param dsn\n * @returns {ConnStr.Spec}\n *\n * @private\n */\nConnStr.prototype._parse = function(dsn) {\n  var out = {};\n\n  if (!dsn) {\n    return out;\n  }\n\n  var parts = /((.*):\\/\\/)?([^\\/?]*)(\\/([^\\?]*))?(\\?(.*))?/.exec(dsn);\n  if (parts[2]) {\n    out.scheme = parts[2];\n  }\n  if (parts[3]) {\n    out.hosts = [];\n    var hostMatcher = /([^;\\,\\:]+)(:([0-9]*))?(;\\,)?/g;\n    while (true) {\n      var hostMatch = hostMatcher.exec(parts[3]);\n      if (!hostMatch) {\n        break;\n      }\n      out.hosts.push([\n        hostMatch[1],\n        hostMatch[3] ? parseInt(hostMatch[3], 10) : 0\n      ]);\n    }\n  }\n  if (parts[5]) {\n    out.bucket = parts[5];\n  }\n  if (parts[7]) {\n    out.options = {};\n    var kvMatcher = /([^=]*)=([^&?]*)[&?]?/g;\n    while (true) {\n      var kvMatch = kvMatcher.exec(parts[7]);\n      if (!kvMatch) {\n        break;\n      }\n      var optKey = qs.unescape(kvMatch[1]);\n      var optVal = qs.unescape(kvMatch[2]);\n      if (out.options.hasOwnProperty(optKey)) {\n        if (Array.isArray(out.options[optKey])) {\n          out.options[optKey].push(optVal);\n        } else {\n          out.options[optKey] = [out.options[optKey], optVal];\n        }\n      } else {\n        out.options[optKey] = optVal;\n      }\n    }\n  }\n\n  return out;\n};\n\n/**\n * @param options\n * @returns {string}\n *\n * @private\n */\nConnStr.prototype._stringify = function(options) {\n  var dsn = '';\n  if (options.scheme) {\n    dsn += options.scheme + '://';\n  }\n  for (var i = 0; i < options.hosts.length; ++i) {\n    var host = options.hosts[i];\n    if (i !== 0) {\n      dsn += ',';\n    }\n    dsn += host[0];\n    if (host[1]) {\n      dsn += ':' + host[1];\n    }\n  }\n  dsn += '/';\n  if (options.bucket) {\n    dsn += options.bucket;\n  }\n  if (options.options) {\n    var isFirstOption = true;\n    for (var j in options.options) {\n      /* istanbul ignore else  */\n      if (options.options.hasOwnProperty(j)) {\n        var opts = [];\n        if (Array.isArray(options.options[j])) {\n          opts = options.options[j];\n        } else {\n          opts.push(options.options[j]);\n        }\n        for (var k = 0; k < opts.length; ++k) {\n          if (isFirstOption) {\n            dsn += '?';\n            isFirstOption = false;\n          } else {\n            dsn += '&';\n          }\n          dsn += qs.escape(j) + '=' + qs.escape(opts[k]);\n        }\n      }\n    }\n  }\n  return dsn;\n};\n\n/**\n * @param {ConnStr.Spec|string} dsn\n * @returns {ConnStr.Spec|string}\n *\n * @private\n */\nConnStr.prototype.normalize = function(dsn) {\n  if (typeof dsn === 'string') {\n    return this._stringify(\n      this._normalize(\n        this._parse(dsn)));\n  }\n  return this._normalize(dsn);\n};\n\n/**\n * @param {string} dsn\n * @returns {ConnStr.Spec}\n *\n * @private\n */\nConnStr.prototype.parse = function(dsn) {\n  return this._normalize(this._parse(dsn));\n};\n\n/**\n * @param {ConnStr.Spec} options\n * @returns {string}\n *\n * @private\n */\nConnStr.prototype.stringify = function(options) {\n  return this._stringify(this._normalize(options));\n};\n\nvar connStr = new ConnStr();\nmodule.exports = connStr;\n\n\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/bucket.js":"'use strict';\n\nvar util = require('util');\nvar fs = require('fs');\nvar path = require('path');\nvar qs = require('querystring');\nvar request = require('request');\nvar dns = require('dns');\nvar events = require('events');\nvar http = require('http');\nvar url = require('url');\n\nvar binding = require('./binding');\nvar connStr = require('./connstr');\nvar errors = require('./errors');\nvar ViewQuery = require('./viewquery');\nvar SpatialQuery = require('./spatialquery');\nvar N1qlQuery = require('./n1qlquery');\nvar SearchQuery = require('./searchquery');\nvar BucketManager = require('./bucketmgr');\n\nvar CONST = binding.Constants;\nvar CBpp = binding.CouchbaseImpl;\n\n/**\n * The *CAS* value is a special object that indicates the current state\n * of the item on the server. Each time an object is mutated on the server, the\n * value is changed. <i>CAS</i> objects can be used in conjunction with\n * mutation operations to ensure that the value on the server matches the local\n * value retrieved by the client.  This is useful when doing document updates\n * on the server as you can ensure no changes were applied by other clients\n * while you were in the process of mutating the document locally.\n *\n * In the Node.js SDK, the CAS is represented as an opaque value. As such,y\n * ou cannot generate CAS objects, but should rather use the values returned\n * from a {@link Bucket.OpCallback}.\n *\n * @typedef {Object} Bucket.CAS\n */\n\n/**\n * @class CouchbaseError\n * @classdesc\n * The virtual class thrown for all Couchnode errors.\n * @private\n * @extends Error\n */\n/**\n * The error code for this error.\n * @var {errors} CouchbaseError#code\n */\n\n/**\n * Single-Key callbacks.\n *\n * This callback is passed to all of the single key functions.\n *\n * It returns a result object containing a combination of a CAS and a value,\n * depending on which operation was invoked.\n *\n * @typedef {function} Bucket.OpCallback\n *\n * @param {undefined|Error} error\n *  The error for the operation. This can either be an Error object\n *  or a value which evaluates to false (null, undefined, 0 or false).\n * @param {Object} result\n *  The result of the operation that was executed.  This usually contains\n *  at least a <i>cas</i> property, and on some operations will contain a\n *  <i>value</i> property as well.\n */\n\n/**\n * Multi-Get Callback.\n *\n * This callback is used to return results from a getMulti operation.\n *\n * @typedef {function} Bucket.MultiGetCallback\n *\n * @param {undefined|number} error\n *  The number of keys that failed to be retrieved.  The precise errors\n *  are available by checking the error property of the individual documents.\n * @param {Object.<Object, Object>} results\n *  This is a map of keys to results.  The result for each key will optionally\n *  contain an error if one occured, or if no error occured will contain\n *  the CAS and value of the document.\n */\n\n/**\n * This is used as a callback from executed queries.  It is a shortcut method\n * that automatically subscribes to the rows and error events of the\n * {@link Bucket.ViewQueryResponse}.\n *\n * @typedef {function} Bucket.QueryCallback\n *\n * @param {undefined|Error} error\n *  The error for the operation. This can either be an Error object\n *  or a falsy value.\n * @param {Array.<Object>} rows\n *  The rows returned from the query\n * @param {Bucket.ViewQueryResponse.Meta} meta\n *  The metadata returned by the query.\n */\n\n/**\n * @class Bucket.TranscoderDoc\n * @classdesc\n * A class used in relation to transcoders\n *\n * @property {Buffer} value\n * @property {number} flags\n *\n * @since 2.0.0\n * @volatile\n */\n/**\n * Transcoder Encoding Function.\n *\n * This function will receive a value when a storage operation is invoked\n * that needs to encode user-provided data for storage into Couchbase.  It\n * expects to be returned a `Buffer` object to store along with an integer\n * representing any flag metadata relating to how to decode the key later\n * using the matching {@link DecoderFunction}.\n *\n * @typedef {function} Bucket.EncoderFunction\n *\n * @param {*} value The value needing encoding.\n * @returns {!Bucket.TranscoderDoc} The data to store to Couchbase.\n */\n/**\n * Transcoder Decoding Function.\n *\n * This function will receive an object containing a `Buffer` value and an\n * integer value representing any flags metadata whenever a retrieval\n * operation is executed.  It is expected that this function will return a\n * value representing the original value stored and encoded with its\n * matching {@link EncoderFunction}.\n *\n * @typedef {function} Bucket.DecoderFunction\n *\n * @param {!Bucket.TranscoderDoc} doc The data from Couchbase to decode.\n * @returns {*} The resulting value.\n */\n\n/**\n * @class\n * The Bucket class represents a connection to a Couchbase bucket.  Never\n * instantiate this class directly.  Instead use the {@link Cluster#openBucket}\n * method instead.\n *\n * @private\n *\n * @since 2.0.0\n * @committed\n */\nfunction Bucket(options) {\n  // We normalize both for consistency as well as to\n  //  create a duplicate object to use\n  options.dsnObj = connStr.normalize(options.dsnObj);\n\n  var bucketDsn = connStr.stringify(options.dsnObj);\n  var bucketUser = options.username;\n  var bucketPass = options.password;\n\n  this._name = options.dsnObj.bucket;\n  this._username = options.username;\n  this._password = options.password;\n\n  this._cb = new CBpp(bucketDsn, bucketUser, bucketPass);\n\n  this.connected = null;\n  this._cb.setConnectCallback(function(err) {\n    if (err) {\n      this.connected = false;\n      return this.emit('error', err);\n    }\n    this.connected = true;\n    this.emit('connect');\n  }.bind(this));\n\n  this.waitQueue = [];\n  this.on('connect', function() {\n    for (var i = 0; i < this.waitQueue.length; ++i) {\n      var itm = this.waitQueue[i];\n      this._invoke(itm[0], itm[1]);\n    }\n    this.waitQueue = [];\n  });\n  this.on('error', function(err) {\n    for (var i = 0; i < this.waitQueue.length; ++i) {\n      var itm = this.waitQueue[i];\n      itm[1][itm[1].length-1](err, null);\n    }\n    this.waitQueue = [];\n  });\n\n  this.httpAgent = new http.Agent();\n  this.httpAgent.maxSockets = 250;\n\n  /* istanbul ignore else  */\n  if (options.dsnObj.hosts.length !== 1 ||\n      options.dsnObj.hosts[0][1] ||\n      (options.dsnObj.scheme !== 'couchbase' &&\n        options.dsnObj.scheme !== 'couchbases')) {\n    // We perform the connect on the next tick to ensure\n    //   consistent behaviour between SRV and non-SRV.\n    process.nextTick(function() {\n      this._cb.connect();\n    }.bind(this));\n  } else {\n    var srvHost = options.dsnObj.hosts[0][0];\n    var srvPrefix = '_' + options.dsnObj.scheme;\n\n    dns.resolveSrv(srvPrefix + '.' + srvHost, function(err, addrs) {\n      if (!err) {\n        options.dsnObj.hosts = [];\n        for (var i = 0; i < addrs.length; ++i) {\n          options.dsnObj.hosts.push([addrs[i].name, addrs[i].port]);\n        }\n        var srvDsn = connStr.stringify(options.dsnObj);\n        this._cb.control(CONST.CNTL_REINIT_DSN, CONST.CNTL_SET, srvDsn);\n      }\n\n      this._cb.connect();\n    }.bind(this));\n  }\n}\nutil.inherits(Bucket, events.EventEmitter);\n\n/**\n * Connected Event.\n * Invoked once the connection has been established successfully.\n *\n * @event Bucket#connect\n *\n * @since 2.0.0\n * @committed\n */\n\n/**\n * Error Event.\n * Invoked if the connection encounters any errors without having an\n * operation context available to handle the error.\n *\n * @event Bucket#error\n * @param {Error} err\n * The error that occured while attempting to connect to the cluster.\n *\n * @since 2.0.0\n * @committed\n */\n\n/**\n * @ignore\n */\n/* istanbul ignore next */\nBucket.prototype.enableN1ql = function(hosts) {\n  if (Array.isArray(hosts)) {\n    this.queryhosts = hosts;\n  } else {\n    this.queryhosts = [hosts];\n  }\n};\n\n/**\n * Returns an instance of a {@link BuckerManager} for performing management\n * operations against a bucket.\n *\n * @returns {BucketManager}\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.manager = function() {\n  return new BucketManager(this);\n};\n\n/**\n * Shuts down this connection.\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.disconnect = function() {\n  if (this.connected !== false) {\n    this.connected = false;\n    this._cb.shutdown();\n  }\n};\n\n/**\n * Configures a custom set of transcoder functions for encoding and decoding\n * values that are being stored or retreived from the server.\n *\n * @param {EncoderFunction} encoder The function for encoding.\n * @param {DecoderFunction} decoder The function for decoding.\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.setTranscoder = function(encoder, decoder) {\n  this._cb.setTranscoder(encoder, decoder);\n};\n\nBucket.prototype._execAndUriParse = function(fn) {\n  var uri = fn.call(this._cb);\n  if (uri.substr(0, 7) === 'http://' ||\n      uri.substr(0, 8) === 'https://') {\n    return url.parse(uri);\n  } else {\n    return url.parse('http://' + uri);\n  }\n};\n\n/**\n * Picks a random CAPI node and builds an http or https request against\n * it using the passed path.\n *\n * @param path\n * @param method\n * @returns {http.ClientRequest}\n *\n * @private\n * @ignore\n */\nBucket.prototype._capiRequest = function(path, method, callback) {\n  var nodeUri = this._execAndUriParse(this._cb.getViewNode);\n  var reqOpts = {\n    agent: this.httpAgent,\n    hostname: nodeUri.hostname,\n    port: nodeUri.port,\n    path: '/' + this._name + '/' + path,\n    method: method,\n    headers: { 'Content-Type': 'application/json' }\n  };\n  if (this._password) {\n    reqOpts.auth = this._username + ':' + this._password;\n  }\n  callback(null, http.request(reqOpts));\n};\n\n/**\n * Picks a random management node and builds an http or https request against\n * it using the passsed path.\n *\n * @param path\n * @returns {http.ClientRequest}\n *\n * @private\n * @ignore\n */\nBucket.prototype._mgmtRequest = function(path, method, callback) {\n  var nodeUri = this._execAndUriParse(this._cb.getMgmtNode);\n  var reqOpts = {\n    hostname: nodeUri.hostname,\n    port: nodeUri.port,\n    path: '/' + path,\n    method: method,\n    headers: { 'Content-Type': 'application/json' }\n  };\n  if (this._password) {\n    reqOpts.auth = this._username + ':' + this._password;\n  }\n  callback(null, http.request(reqOpts));\n};\n\n/**\n * @class Meta\n * @classdesc\n * The meta-information available from a view query response.\n * @private\n * @memberof Bucket.ViewQueryResponse\n */\n/**\n * The total number of rows available in the index of the view\n * that was queried.\n *\n * @var {number} Bucket.ViewQueryResponse.Meta#total_rows\n * @since 2.0.0\n * @committed\n */\n\n/**\n * Emitted whenever a new row is available from a queries result set.\n *\n * @event Bucket.ViewQueryResponse#row\n * @param {Object} row\n * @param {Bucket.ViewQueryResponse.Meta} meta\n *\n * @since 2.0.0\n * @committed\n */\n/**\n * Emitted whenever all rows are available from a queries result set.\n *\n * @event Bucket.ViewQueryResponse#rows\n * @param {Object[]} rows\n * @param {Bucket.ViewQueryResponse.Meta} meta\n *\n * @since 2.0.0\n * @committed\n */\n/**\n * Emitted once a query has completed executing and emitting all rows.\n *\n * @event Bucket.ViewQueryResponse#end\n * @param {Bucket.ViewQueryResponse.Meta} meta\n *\n * @since 2.0.0\n * @committed\n */\n/**\n * Emitted if an error occurs while executing a query.\n *\n * @event Bucket.ViewQueryResponse#error\n * @param {Error} error\n *\n * @since 2.0.0\n * @committed\n */\n\n/**\n * An event emitter allowing you to bind to various query result set\n * events.\n *\n * @constructor\n *\n * @private\n * @memberof Bucket\n * @extends events.EventEmitter\n *\n * @since 2.0.0\n * @committed\n */\nfunction ViewQueryResponse() {\n}\nutil.inherits(ViewQueryResponse, events.EventEmitter);\n\n/**\n * Executes a view http request.\n *\n * @param {string} viewtype\n * @param {string} ddoc\n * @param {string} name\n * @param {Object} q\n * @param {ViewQueryResponse} emitter\n *\n * @private\n * @ignore\n */\nBucket.prototype._viewReq = function(viewtype, ddoc, name, q, emitter) {\n  var isSpatial = false;\n  if (viewtype === '_spatial') {\n    isSpatial = true;\n  }\n\n  var includeDocs = false;\n  var opts = {};\n  for (var i in q) {\n    if (q.hasOwnProperty(i)) {\n      if (i === 'include_docs') {\n        if (q[i] && q[i] === 'true') {\n          includeDocs = true;\n        } else {\n          includeDocs = false;\n        }\n      } else {\n        opts[i] = q[i];\n      }\n    }\n  }\n\n  var rows = [];\n  this._cb.viewQuery(\n      isSpatial,\n      ddoc, name,\n      qs.stringify(opts),\n      includeDocs,\n  function(errCode, val) {\n    if (errCode === -1) {\n      var row = val;\n      if (rows) {\n        if (events.EventEmitter.listenerCount(emitter, 'rows') > 0) {\n          rows.push(row);\n        } else {\n          rows = null;\n        }\n      }\n      emitter.emit('row', row);\n    } else if (errCode === 0) {\n      var meta = val;\n      if (rows) {\n        emitter.emit('rows', rows, meta);\n      }\n      emitter.emit('end', meta);\n    } else {\n      var errStr = val;\n      var jsonError = JSON.parse(errStr);\n      var errorMessage = 'unknown error : error parsing failed';\n      if (jsonError) {\n        errorMessage = jsonError.message;\n        if (jsonError.error || jsonError.reason) {\n          var subError = jsonError.error + ': ' + jsonError.reason;\n          if (!errorMessage) {\n            errorMessage = subError;\n          } else {\n            errorMessage += ' (' + subError + ')';\n          }\n        }\n      }\n      emitter.emit('error', new Error(errorMessage));\n    }\n  });\n};\n\n/**\n * Performs a view request.\n *\n * @param {string} viewtype\n * @param {string} ddoc\n * @param {string} name\n * @param {Object} q\n * @param {function(err,res,meta)} callback\n *\n * @private\n * @ignore\n */\nBucket.prototype._view = function(viewtype, ddoc, name, q, callback) {\n  var path = '_design/' + ddoc + '/' + viewtype + '/' +\n      name + '?' + qs.stringify(q);\n\n  var req = new ViewQueryResponse();\n\n  var invokeCb = callback;\n  if (!invokeCb) {\n    invokeCb = function(err) {\n      req.emit('error', err);\n    };\n  }\n\n  this._maybeInvoke(this._viewReq.bind(this),\n      [viewtype, ddoc, name, q, req, invokeCb]);\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n\n  return req;\n};\n\n/**\n * @class Meta\n * @classdesc\n * The meta-information available from a view query response.\n * @private\n * @memberof Bucket.N1qlQueryResponse\n */\n/**\n * The identifier for this query request.\n *\n * @var {number} Bucket.N1qlQueryResponse.Meta#requestID\n * @since 2.0.8\n * @committed\n */\n\n/**\n * Emitted whenever a new row is available from a queries result set.\n *\n * @event Bucket.N1qlQueryResponse#row\n * @param {Object} row\n * @param {Bucket.N1qlQueryResponse.Meta} meta\n *\n * @since 2.0.8\n * @committed\n */\n/**\n * Emitted whenever all rows are available from a queries result set.\n *\n * @event Bucket.N1qlQueryResponse#rows\n * @param {Object[]} rows\n * @param {Bucket.N1qlQueryResponse.Meta} meta\n *\n * @since 2.0.8\n * @committed\n */\n/**\n * Emitted once a query has completed executing and emitting all rows.\n *\n * @event Bucket.N1qlQueryResponse#end\n * @param {Bucket.N1qlQueryResponse.Meta} meta\n *\n * @since 2.0.8\n * @committed\n */\n/**\n * Emitted if an error occurs while executing a query.\n *\n * @event Bucket.N1qlQueryResponse#error\n * @param {Error} error\n *\n * @since 2.0.8\n * @committed\n */\n\n/**\n * An event emitter allowing you to bind to various query result set\n * events.\n *\n * @constructor\n *\n * @private\n * @memberof Bucket\n * @extends events.EventEmitter\n *\n * @since 2.0.8\n * @committed\n */\nfunction N1qlQueryResponse() {\n}\nutil.inherits(N1qlQueryResponse, events.EventEmitter);\nBucket.N1qlQueryResponse = N1qlQueryResponse;\n\n/**\n * Executes a N1QL http request.\n *\n * @param {string|undefined} host\n * @param {string} q\n * @param {boolean} adhoc\n * @param {N1qlQueryResponse} emitter\n *\n * @private\n * @ignore\n */\nBucket.prototype._n1qlReq = function(host, q, adhoc, emitter) {\n  var rows = [];\n  this._cb.n1qlQuery(\n      host, q, adhoc,\n  function(errCode, val) {\n    if (errCode === -1) { // Row\n      var row = val;\n      if (rows) {\n        if (events.EventEmitter.listenerCount(emitter, 'rows') > 0) {\n          rows.push(row);\n        } else {\n          rows = null;\n        }\n      }\n      emitter.emit('row', row);\n    } else if (errCode === 0) { // Success\n      var meta = val;\n      if (rows) {\n        emitter.emit('rows', rows, meta);\n      }\n      emitter.emit('end', meta);\n    } else { // Error\n      var errStr = val;\n      var jsonError = null;\n      try {\n        jsonError = JSON.parse(errStr);\n      } catch(e) { }\n      var err;\n      if (jsonError && jsonError.errors && jsonError.errors.length > 0) {\n        var firstErr = jsonError.errors[0];\n        err = new Error(firstErr.msg);\n        err.requestID = jsonError.requestID;\n        err.code = firstErr.code;\n        err.otherErrors = [];\n\n        for (var i = 1; i < jsonError.errors.length; ++i) {\n          var nextErr = jsonError.errors[i];\n          var otherErr = new Error(nextErr.msg);\n          otherErr.code = nextErr.code;\n          err.otherErrors.push(otherErr);\n        }\n      } else {\n        err = new Error('An unknown N1QL error occured.' +\n            ' This is usually related to an out-of-memory condition.');\n      }\n\n      emitter.emit('error', err);\n    }\n  });\n};\n\n/**\n * Executes a N1QL query from a N1QL query string.\n *\n * @param {string} query\n * @param {function} callback\n\n * @private\n * @ignore\n */\nBucket.prototype._n1ql = function(query, params, callback) {\n  var host;\n  if (this.queryhosts) {\n    var qhosts = this.queryhosts;\n    host = qhosts[Math.floor(Math.random() * qhosts.length)];\n    if (host.indexOf(':') === -1) {\n      host = host + ':8093';\n    }\n  }\n\n  var req = new N1qlQueryResponse();\n\n  var invokeCb = callback;\n  if (!invokeCb) {\n    invokeCb = function(err) {\n      req.emit('error', err);\n    };\n  }\n\n  this._maybeInvoke(this._n1qlReq.bind(this),\n      [host, query.toObject(params), query.isAdhoc, req, invokeCb]);\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n\n  return req;\n};\n\n/**\n * @class Meta\n * @classdesc\n * The meta-information available from a view query response.\n * @private\n * @memberof Bucket.N1qlQueryResponse\n */\n/**\n * The status information for this query, includes properties\n * such as total, failed and successful.\n *\n * @var {number} Bucket.FtsQueryResponse.Meta#status\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * Any non-fatal errors that occured during query processing.\n *\n * @var {number} Bucket.FtsQueryResponse.Meta#errors\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * The total number of hits that were available for this seach query.\n *\n * @var {number} Bucket.FtsQueryResponse.Meta#totalHits\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * The resulting facet information for any facets that were specified\n * in the search query.\n *\n * @var {number} Bucket.FtsQueryResponse.Meta#facets\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * The time spent processing this query.\n *\n * @var {number} Bucket.FtsQueryResponse.Meta#took\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * The maximum score out of all the results in this query.\n *\n * @var {number} Bucket.FtsQueryResponse.Meta#maxScore\n * @since 2.1.7\n * @uncommitted\n */\n\n/**\n * Emitted whenever a new row is available from a queries result set.\n *\n * @event Bucket.FtsQueryResponse#row\n * @param {Object} row\n * @param {Bucket.FtsQueryResponse.Meta} meta\n *\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * Emitted whenever all rows are available from a queries result set.\n *\n * @event Bucket.FtsQueryResponse#rows\n * @param {Object[]} rows\n * @param {Bucket.FtsQueryResponse.Meta} meta\n *\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * Emitted once a query has completed executing and emitting all rows.\n *\n * @event Bucket.FtsQueryResponse#end\n * @param {Bucket.FtsQueryResponse.Meta} meta\n *\n * @since 2.1.7\n * @uncommitted\n */\n/**\n * Emitted if an error occurs while executing a query.\n *\n * @event Bucket.FtsQueryResponse#error\n * @param {Error} error\n *\n * @since 2.1.7\n * @uncommitted\n */\n\n/**\n * An event emitter allowing you to bind to various query result set\n * events.\n *\n * @constructor\n *\n * @private\n * @memberof Bucket\n * @extends events.EventEmitter\n *\n * @since 2.1.7\n * @uncommitted\n */\nfunction FtsQueryResponse() {\n}\nutil.inherits(FtsQueryResponse, events.EventEmitter);\nBucket.FtsQueryResponse = FtsQueryResponse;\n\n/**\n * Executes a FTS http request.\n *\n * @param {SearchQuery} q\n * @param {FtsQueryResponse} emitter\n *\n * @private\n * @ignore\n */\nBucket.prototype._ftsReq = function(q, emitter) {\n  var rows = [];\n  this._cb.ftsQuery(\n      q,\n      function(errCode, val) {\n        if (errCode === -1) { // Row\n          var row = val;\n          if (rows) {\n            if (events.EventEmitter.listenerCount(emitter, 'rows') > 0) {\n              rows.push(row);\n            } else {\n              rows = null;\n            }\n          }\n          emitter.emit('row', row);\n        } else if (errCode === 0) { // Success\n          var meta = val;\n          if (meta instanceof Object) {\n            meta.totalHits = meta.total_hits;\n            meta.maxScore = meta.max_score;\n            delete meta.total_hits;\n            delete meta.max_score;\n          }\n          if (rows) {\n            emitter.emit('rows', rows, meta);\n          }\n          emitter.emit('end', meta);\n        } else { // Error\n          var err = new Error('An FTS error occured: ' + val);\n          emitter.emit('error', err);\n        }\n      });\n};\n\n/**\n * Executes a FTS query from a SearchQuery.\n *\n * @param {SearchQuery} query\n * @param {function} callback\n\n * @private\n * @ignore\n */\nBucket.prototype._fts = function(query, callback) {\n  var req = new FtsQueryResponse();\n\n  var invokeCb = callback;\n  if (!invokeCb) {\n    invokeCb = function(err) {\n      req.emit('error', err);\n    };\n  }\n\n  this._maybeInvoke(this._ftsReq.bind(this),\n      [query, req, invokeCb]);\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n\n  return req;\n};\n\n/**\n * Executes a previously prepared query object.  This could be a\n * {@link ViewQuery}, {@link N1qlQuery} or a {@link SearchQuery}.\n *\n * Note: SearchQuery queries are currently an uncommitted interface and may be\n * subject to change in a future release.\n *\n * @param {ViewQuery|N1qlQuery|SearchQuery} query\n * The query to execute.\n * @param {Object|Array} [params]\n * A list or map to do replacements on a N1QL query.\n * @param {Bucket.QueryCallback} callback\n * @returns\n * {Bucket.ViewQueryResponse|Bucket.N1qlQueryResponse|Bucket.FtsQueryResponse}\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.query = function(query, params, callback) {\n  if (params instanceof Function) {\n    callback = arguments[1];\n    params = undefined;\n  }\n\n  if (query instanceof ViewQuery) {\n    return this._view(\n        '_view', query.ddoc, query.name, query.options, callback);\n  } else if (query instanceof SpatialQuery) {\n    return this._view(\n        '_spatial', query.ddoc, query.name, query.options, callback);\n  } else if (query instanceof N1qlQuery) {\n    return this._n1ql(\n        query, params, callback\n    );\n  } else if (query instanceof SearchQuery) {\n    return this._fts(\n        query, callback\n    );\n  } else {\n    throw new TypeError(\n        'First argument needs to be a ViewQuery, SpatialQuery or N1qlQuery.');\n  }\n};\n\n/**\n * Gets or sets a libcouchbase instance setting.\n *\n * @private\n * @ignore\n */\nBucket.prototype._ctl = function(cc, value) {\n  if (value !== undefined) {\n    return this._cb.control.call(this._cb, cc, CONST.CNTL_SET, value);\n  } else {\n    return this._cb.control.call(this._cb, cc, CONST.CNTL_GET);\n  }\n};\n\n\n/**\n * Creates an durability failure Error object.\n *\n * @param {Error} innerError\n * The internal error that occured that caused the durability requirements to\n * fail to succeed.\n * @returns {CouchbaseError}\n *\n * @private\n * @ignore\n */\nfunction _endureError(innerError)\n{\n  var out_error = new binding.Error('Durability requirements failed');\n  out_error.code = CONST['ErrorCode::DURABILITY_FAILED'];\n  out_error.innerError = innerError;\n  return out_error;\n}\n\n/**\n * Common callback interceptor for durability requirements.  This function\n * will wrap user-provided callbacks in a handler which will ensure all\n * durability requirements are met prior to invoking the user-provided callback.\n *\n * @private\n * @ignore\n */\nBucket.prototype._interceptEndure =\n    function(key, options, is_delete, callback) {\n  if (!options.persist_to && !options.replicate_to) {\n    // leave early if we can\n    return callback;\n  }\n\n  // Return our interceptor\n  var _this = this;\n  return function(err, res) {\n    if (err) {\n      callback(err, res);\n      return;\n    }\n\n    _this._cb.durability.call(_this._cb, key, options.hashkey, res.cas,\n        options.persist_to, options.replicate_to, is_delete,\n        function(endure_err) {\n      if(endure_err) {\n        callback(_endureError(endure_err), res);\n        return;\n      }\n\n      callback(err, res);\n    });\n  };\n};\n\n/**\n * Invokes an operation and dispatches a callback error if one occurs.\n *\n * @param {Function} fn The operation callback to invoke.\n * @param {Array.<*>} args An array of arguments to pass to the function.\n *\n * @private\n * @ignore\n */\nBucket.prototype._invoke = function(fn, args) {\n  try {\n    fn.apply(this._cb, args);\n  } catch(e) {\n    args[args.length-1](e, null);\n  }\n};\n\n/**\n * Will either invoke the binding method specified by fn, or alternatively\n * push the operation to a queue which is flushed once a connection\n * has been established or failed.\n *\n * @param {Function} fn The binding method to invoke.\n * @param {Array} args A list of arguments for the method.\n *\n * @private\n * @ignore\n */\nBucket.prototype._maybeInvoke = function(fn, args) {\n  if (this.connected === true) {\n    this._invoke(fn, args);\n  } else if (this.connected === false) {\n    throw new Error('cannot perform operations on a shutdown bucket');\n  } else {\n    this.waitQueue.push([fn, args]);\n  }\n};\n\n/**\n * Deduces if the C++ binding layer will accept the passed value\n * as an appropriately typed key.\n *\n * @param {string|Buffer} key The key\n * @returns {boolean}\n *\n * @private\n * @ignore\n */\nBucket.prototype._isValidKey = function(key) {\n  return typeof key === 'string' || key instanceof Buffer;\n};\n\n/**\n * Deduces if the C++ binding layer will accept the passed value\n * as an appropriately typed path.\n *\n * @param {string|Buffer} path The path\n * @returns {boolean}\n *\n * @private\n * @ignore\n */\nBucket.prototype._isValidPath = function(path) {\n  return typeof path === 'string';\n};\n\n/**\n * Checks that the passed options have a valid hashkey specified.\n * Note that hashkey/groupid is not a supported feature of Couchbase Server\n * and this client. It should be considered volatile and experimental. Using\n * this could lead to an unbalanced cluster, inability to interoperate with the\n * data from other languages, not being able to use the Couchbase Server UI to\n * look up documents and other possible future upgrade/migration concerns.\n *\n * @param {Object} options The options objects to check.\n *\n * @private\n * @ignore\n */\nBucket.prototype._checkHashkeyOption = function(options) {\n  if (options.hashkey !== undefined) {\n    if (!this._isValidKey(options.hashkey)) {\n      throw new TypeError('hashkey option needs to be a string or buffer.');\n    }\n  }\n};\n\n/**\n * Checks that the passed options have a valid expiry specified.\n *\n * @param {Object} options The options objects to check.\n *\n * @private\n * @ignore\n */\nBucket.prototype._checkExpiryOption = function(options) {\n  if (options.expiry !== undefined) {\n    if (typeof options.expiry !== 'number') {\n      throw new TypeError('expiry option needs to be a number.');\n    }\n    if (options.expiry < 0 || options.expiry > 2147483647) {\n      throw new TypeError('expiry option needs to between 0 and 2147483647.');\n    }\n  }\n};\n\n/**\n * Checks that the passed options have a valid cas specified.\n *\n * @param {Object} options The options objects to check.\n *\n * @private\n * @ignore\n */\nBucket.prototype._checkCasOption = function(options) {\n  if (options.cas !== undefined) {\n    if (typeof options.cas !== 'object' && typeof options.cas !== 'string') {\n      throw new TypeError('cas option needs to be a CAS object or string.');\n    }\n  }\n};\n\n/**\n * Checks that the passed options have a valid persist_to\n * and replicate_to specified.\n *\n * @param {Object} options The options objects to check.\n *\n * @private\n * @ignore\n */\nBucket.prototype._checkDuraOptions = function(options) {\n  if (options.persist_to !== undefined) {\n    if (typeof options.persist_to !== 'number' ||\n      options.persist_to < 0 || options.persist_to > 8) {\n      throw new TypeError(\n        'persist_to option needs to be an integer between 0 and 8.');\n    }\n  }\n  if (options.replicate_to !== undefined) {\n    if (typeof options.replicate_to !== 'number' ||\n      options.replicate_to < 0 || options.replicate_to > 8) {\n      throw new TypeError(\n        'replicate_to option needs to be an integer between 0 and 8.');\n    }\n  }\n};\n\n/**\n * Retrieves a document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.get = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(this._cb.get, [key, options.hashkey, 0, 0, callback]);\n};\n\n/**\n * Retrieves a list of keys\n *\n * @param {Array.<Buffer|string>} keys\n * The target document keys.\n * @param {Object} [options]\n *  @param {number} [options.batch_size=0]\n *  The size of each batch that is used to fetch the specified keys.  A\n *  batch size of zero indicates to perform all operations simultanously.\n * @param {Bucket.MultiGetCallback} callback\n *\n * @see Bucket#get\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.getMulti = function(keys, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!Array.isArray(keys) || keys.length === 0) {\n    throw new TypeError('First argument needs to be an array of length > 0.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n\n  if (!options.batch_size) {\n    options.batch_size = keys.length;\n  }\n\n  var self = this;\n  var outMap = {};\n  var sentCount = 0;\n  var resCount = 0;\n  var errCount = 0;\n  function getOne() {\n    var key = keys[sentCount++];\n    self.get(key, function(err, res) {\n      resCount++;\n      if (err) {\n        errCount++;\n        outMap[key] = { error: err };\n      } else {\n        outMap[key] = res;\n      }\n      if (sentCount < keys.length) {\n        getOne();\n        return;\n      } else if (resCount === keys.length) {\n        callback(errCount, outMap);\n        return;\n      }\n    });\n  }\n  for (var i = 0; i < options.batch_size; ++i) {\n    getOne();\n  }\n};\n\n/**\n * Retrieves a document and updates the expiry of the item at the same time.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {number} expiry\n * The expiration time to use. If a value of 0 is provided, then the\n * current expiration time is cleared and the key is set to\n * never expire. Otherwise, the key is updated to expire in the\n * time provided (in seconds).\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @see Bucket#get\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.getAndTouch = function(key, expiry, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (typeof key !== 'string' && !(key instanceof Buffer)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof expiry !== 'number' || expiry < 0) {\n    throw new TypeError('Second argument needs to be 0 or a positive integer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(this._cb.get, [key, options.hashkey, expiry, 0, callback]);\n};\n\n/**\n * Lock the document on the server and retrieve it. When an document is locked,\n * its CAS changes and subsequent operations on the document (without providing\n * the current CAS) will fail until the lock is no longer held.\n *\n * This function behaves identically to {@link Bucket#get} in that it will\n * return the value. It differs in that the document is also locked. This\n * ensures that attempts by other client instances to access this document\n * while the lock is held will fail.\n *\n * Once locked, a document can be unlocked either by explicitly calling\n * {@link Bucket#unlock} or by performing a storage operation\n * (e.g. {@link Bucket#upsert}, {@link Bucket#replace}, {@link Bucket::append})\n * with the current CAS value.  Note that any other lock operations on this\n * key will fail while a document is locked.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n *  @param {number} [options.lockTime=15]\n *  The duration of time the lock should be held for. Note that the maximum\n *  duration for a lock is 30 seconds, and if a higher value is specified,\n *  it will be rounded to this number.\n * @param {Bucket.OpCallback} callback\n *\n * @see Bucket#get\n * @see Bucekt#unlock\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.getAndLock = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  if (options.lockTime !== undefined) {\n    if (typeof options.lockTime !== 'number' || options.lockTime < 1) {\n      throw new TypeError('lockTime option needs to be a positive integer.');\n    }\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(this._cb.get,\n    [key, options.hashkey, options.lockTime, 1, callback]);\n};\n\n/**\n * Get a document from a replica server in your cluster.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n *  @param {number} [options.index=undefined]\n *  The index for which replica you wish to retrieve this value from, or\n *  if undefined, use the value from the first server that replies.\n * @param {Bucket.OpCallback} callback\n *\n * @see Bucket#get\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.getReplica = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n  if (typeof key !== 'string' && !(key instanceof Buffer)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  if (options.hashkey !== undefined) {\n    if (!this._isValidKey(options.hashkey)) {\n      throw new TypeError('hashkey option needs to be a string or buffer.');\n    }\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(this._cb.getReplica,\n    [key, options.hashkey, options.index, callback]);\n};\n\n/**\n * Update the document expiration time.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {number} expiry\n * The expiration time to use. If a value of 0 is provided, then the\n * current expiration time is cleared and the key is set to\n * never expire. Otherwise, the key is updated to expire in the\n * time provided (in seconds).  Values larger than 30*24*60*60 seconds\n * (30 days) are interpreted as absolute times (from the epoch).\n * @param {Object} [options]\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback.\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.touch = function(key, expiry, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof expiry !== 'number' || expiry < 0) {\n    throw new TypeError('Second argument needs to be 0 or a positive integer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkCasOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(this._cb.get, [key, options.hashkey, expiry, 0, callback]);\n};\n\n/**\n * Unlock a previously locked document on the server.  See the\n * {@link Bucket#lock} method for more details on locking.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Bucket.CAS} cas\n * The CAS value returned when the key was locked.  This operation will fail\n * if the CAS value provided does not match that which was the result of the\n * original lock operation.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @see Bucket#getAndLock\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.unlock = function(key, cas, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n  if (typeof key !== 'string' && !(key instanceof Buffer)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof cas !== 'object') {\n    throw new TypeError('Second argument needs to be a CAS object.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(this._cb.unlock, [key, options.hashkey, cas, callback]);\n};\n\n/**\n * Deletes a document on the server.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n *  @param {Bucket.CAS} [options.cas=undefined]\n *  The CAS value to check. If the item on the server contains a different\n *  CAS value, the operation will fail.  Note that if this option is undefined,\n *  no comparison will be performed.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.remove = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkCasOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(this._cb.remove,\n      [key, options.hashkey, options.cas,\n        this._interceptEndure(key, options, 1, callback)]);\n};\n\n/**\n * Performs a storage operation.  This is a single handler function for all\n * possible storage operations.  This is thanks to libcouchbase handling them\n * all as a single entity as well.\n *\n * @param {string|Buffer} key\n * @param {*} value\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n * @param {number} opType\n *\n * @private\n * @ignore\n */\nBucket.prototype._store = function(key, value, options, callback, opType) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (value === undefined) {\n    throw new TypeError('Second argument must not be undefined.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkExpiryOption(options);\n  this._checkCasOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(this._cb.store,\n    [key, options.hashkey, value, options.expiry, options.cas, opType,\n      this._interceptEndure(key, options, 0, callback)]);\n};\n\n/**\n * Stores a document to the bucket.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {!*} value\n * The document's contents.\n * @param {Object} [options]\n *  @param {Bucket.CAS} [options.cas=undefined]\n *  The CAS value to check. If the item on the server contains a different\n *  CAS value, the operation will fail.  Note that if this option is undefined,\n *  no comparison will be performed.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.upsert = function(key, value, options, callback) {\n  this._store(key, value, options, callback, CONST.SET);\n};\n\n/**\n * Identical to {@link Bucket#upsert} but will fail if the document already\n * exists.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {!*} value\n * The document's contents.\n * @param {Object} [options]\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.insert = function(key, value, options, callback) {\n  this._store(key, value, options, callback, CONST.ADD);\n};\n\n/**\n * Identical to {@link Bucket#upsert}, but will only succeed if the document\n * exists already (i.e. the inverse of {@link Bucket#insert}).\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {!*} value\n * The document's contents.\n * @param {Object} [options]\n *  @param {Bucket.CAS} [options.cas=undefined]\n *  The CAS value to check. If the item on the server contains a different\n *  CAS value, the operation will fail.  Note that if this option is undefined,\n *  no comparison will be performed.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.replace = function(key, value, options, callback) {\n  this._store(key, value, options, callback, CONST.REPLACE);\n};\n\n/**\n * Similar to {@link Bucket#upsert}, but instead of setting a new key,\n * it appends data to the existing key. Note that this function only makes\n * sense when the stored data is a string; 'appending' to a JSON document may\n * result in parse errors when the document is later retrieved.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {!*} fragment\n * The document's contents to append.\n * @param {Object} [options]\n *  @param {Bucket.CAS} [options.cas=undefined]\n *  The CAS value to check. If the item on the server contains a different\n *  CAS value, the operation will fail.  Note that if this option is undefined,\n *  no comparison will be performed.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @see Bucket#prepend\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.append = function(key, fragment, options, callback) {\n  this._store(key, fragment, options, callback, CONST.APPEND);\n};\n\n/**\n * Like {@linkcode Bucket#append}, but prepends data to the existing value.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {!*} fragment\n * The document's contents to prepend.\n * @param {Object} [options]\n *  @param {Bucket.CAS} [options.cas=undefined]\n *  The CAS value to check. If the item on the server contains a different\n *  CAS value, the operation will fail.  Note that if this option is undefined,\n *  no comparison will be performed.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @see Bucket#append\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.prepend = function(key, fragment, options, callback) {\n  this._store(key, fragment, options, callback, CONST.PREPEND);\n};\n\n/**\n * Increments or decrements a key's numeric value.\n *\n * Note that JavaScript does not support 64-bit integers (while libcouchbase\n * and the server do). You might receive an inaccurate value if the\n * number is greater than 53-bits (JavaScript's maximum integer precision).\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {number} delta\n * The amount to add or subtract from the counter value.  This value may be\n * any non-zero integer.\n * @param {Object} [options]\n *  @param {number} [options.initial=undefined]\n *  Sets the initial value for the document if it does not exist.  Specifying\n *  a value of undefined will cause the operation to fail if the document\n *  does not exist, otherwise this value must be equal to or greater than 0.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.0.0\n * @committed\n */\nBucket.prototype.counter = function(key, delta, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof delta !== 'number' || delta === 0) {\n    throw new TypeError('Second argument must be a non-zero integer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  if (options.initial) {\n    if (typeof options.initial !== 'number' || options.initial < 0) {\n      throw new TypeError('initial option must be 0 or a positive integer.');\n    }\n  }\n  this._checkHashkeyOption(options);\n  this._checkExpiryOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(this._cb.arithmetic,\n    [key, options.hashkey, options.expiry, delta, options.initial,\n      this._interceptEndure(key, options, 0, callback)]);\n};\n\n/**\n * Retrieves a single item from a map document by its key.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {string} path\n * The key within the map.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.mapGet = function(key, path, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  this.lookupIn(key, options).get(path).execute(function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    try {\n      res.value = res.contentByIndex(0);\n    } catch (e) {\n      callback(e, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Removes a specified key from the specified map document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {string} path\n * The key within the map.\n * @param {Object} [options]\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.mapRemove = function(key, path, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  this.mutateIn(key, options).remove(path).execute(function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Returns the current number of items in a map document.\n * PERFORMANCE NOTICE: This currently performs a full document fetch...\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.mapSize = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  this.get(key, options, function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    var mapValues = res.value;\n    res.value = 0;\n\n    for (var i in mapValues) {\n      if (mapValues.hasOwnProperty(i)) {\n        res.value++;\n      }\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Inserts an item to a map document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {string} path\n * The key within the map.\n * @param value\n * The value to store within the map.\n * @param {Object} [options]\n *  @param {boolean} [options.createMap=false]\n *  Creates the document if it does not already exist.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.mapAdd = function(key, path, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[3];\n    options = {};\n  }\n\n  var self = this;\n  this.mutateIn(key, options).insert(path, value, false)\n      .execute(function(err, res) {\n    if (err) {\n      if (err.code === errors.keyNotFound && options.createMap) {\n        var data = {};\n        data[path] = value;\n\n        self.insert(key, data, options, function(err, insertRes) {\n          if (err) {\n            if (err.code === errors.keyAlreadyExists) {\n              self.mapAdd(key, path, value, options, callback);\n              return;\n            }\n\n            callback(err, null);\n            return;\n          }\n\n          callback(null, insertRes);\n        });\n        return;\n      }\n\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Retrieves an item from a list document by index.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {number} index\n * The index to retrieve within the list.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.listGet = function(key, index, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  this.lookupIn(key, options).get('[' + index + ']')\n      .execute(function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    try {\n      res.value = res.contentByIndex(0);\n    } catch (e) {\n      callback(e, null);\n      return;\n    }\n\n\n    callback(null, res);\n  });\n};\n\n/**\n * Inserts an item to the end of a list document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param value\n * The value to store within the list.\n * @param {Object} [options]\n *  @param {boolean} [options.createList=false]\n *  Creates the document if it does not already exist.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.listAppend = function(key, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  var self = this;\n  this.mutateIn(key, options).arrayAppend('', value, false)\n      .execute(function(err, res) {\n    if (err) {\n      if (err.code === errors.keyNotFound && options.createList) {\n        var data = [];\n        data.push(value);\n\n        self.insert(key, data, options, function(err, insertRes) {\n          if (err) {\n            if (err.code === errors.keyAlreadyExists) {\n              self.listAppend(key, value, options, callback);\n              return;\n            }\n\n            callback(err, null);\n            return;\n          }\n\n          callback(null, insertRes);\n        });\n        return;\n      }\n\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * @deprecated\n * Alias for listAppend\n */\nBucket.prototype.listPush = Bucket.prototype.listAppend;\n\n/**\n * Inserts an item to the beginning of a list document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param value\n * The value to store within the list.\n * @param {Object} [options]\n *  @param {boolean} [options.createList=false]\n *  Creates the document if it does not already exist.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.listPrepend = function(key, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  var self = this;\n  this.mutateIn(key, options).arrayPrepend('', value, false)\n      .execute(function(err, res) {\n    if (err) {\n      if (err.code === errors.keyNotFound && options.createList) {\n        var data = [value];\n\n        self.insert(key, data, options, function(err, insertRes) {\n          if (err) {\n            if (err.code === errors.keyAlreadyExists) {\n              self.listPrepend(key, value, options, callback);\n              return;\n            }\n\n            callback(err, null);\n            return;\n          }\n\n          callback(null, insertRes);\n        });\n        return;\n      }\n\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * @deprecated\n * Alias for listPrepend\n */\nBucket.prototype.listShift = Bucket.prototype.listPrepend;\n\n    /**\n * Removes an item from a list document by its index.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {number} index\n * The index to retrieve within the list.\n * @param {Object} [options]\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.listRemove = function(key, index, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  this.mutateIn(key, options).remove('[' + index + ']')\n      .execute(function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Replaces the item at a particular index of a list document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {number} index\n * The index to retrieve within the list.\n * @param value\n * The value to store within the list.\n * @param {Object} [options]\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.listSet = function(key, index, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[3];\n    options = {};\n  }\n\n  this.mutateIn(key, options).replace('[' + index + ']', value)\n      .execute(function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Returns the current number of items in a list.\n * PERFORMANCE NOTICE: This currently performs a full document fetch...\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.listSize = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  this.get(key, options, function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    res.value = res.value.length;\n    callback(null, res);\n  });\n};\n\n/**\n * Adds a new value to a set document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param value\n * The value to store within the list.\n * @param {Object} [options]\n *  @param {boolean} [options.createSet=false]\n *  Creates the document if it does not already exist.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.setAdd = function(key, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  var self = this;\n  this.mutateIn(key, options).arrayAddUnique('', value, false)\n      .execute(function(err, res) {\n    if (err) {\n      if (err.code === errors.keyNotFound && options.createSet) {\n        var data = [value];\n\n        self.insert(key, data, options, function(err, insertRes) {\n          if (err) {\n            if (err.code === errors.keyAlreadyExists) {\n              self.setAdd(key, value, options, callback);\n              return;\n            }\n\n            callback(err, null);\n            return;\n          }\n\n          callback(null, insertRes);\n        });\n        return;\n      }\n\n      callback(err, null);\n      return;\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Checks if a particular value exists within the specified set document.\n * PERFORMANCE WARNING: This performs a full set fetch and compare.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param value\n * The value to look for in the set.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.setExists = function(key, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  this.get(key, options, function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    var setValues = res.value;\n    res.value = false;\n\n    for(var i in setValues) {\n      if (setValues.hasOwnProperty(i)) {\n        if (setValues[i] === value) {\n          res.value = true;\n        }\n      }\n    }\n\n    callback(null, res);\n  });\n};\n\n/**\n * Returns the current number of values in a set.\n * PERFORMANCE NOTICE: This currently performs a full document fetch...\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.setSize = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  this.get(key, options, function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    res.value = res.value.length;\n    callback(null, res);\n  });\n};\n\n/**\n * Removes a specified value from the specified set document.\n * WARNING: This relies on Javascripts's equality comparison behaviour!\n * PERFORMANCE WARNING: This performs full set fetch, modify, store cycles.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param value\n * The value to remove from the set.\n * @param {Object} [options]\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.setRemove = function(key, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  var self = this;\n  this.get(key, options, function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    var newValues = [];\n\n    for (var i = 0; i < res.value.length; ++i) {\n      if (res.value[i] !== value) {\n        newValues.push(res.value[i]);\n      }\n    }\n\n    var replaceOpts = {};\n    for (var j in options) {\n      if (options.hasOwnProperty(j)) {\n        replaceOpts[j] = options[j];\n      }\n    }\n\n    if (replaceOpts.cas === undefined) {\n      replaceOpts.cas = res.cas;\n    }\n\n    self.replace(key, newValues, options, function(err, replaceRes) {\n      if (err) {\n        if (err.code === errors.keyAlreadyExists && options.cas === undefined) {\n          self.setRemove(key, value, options, callback);\n          return;\n        }\n\n        callback(err, null);\n        return;\n      }\n\n      callback(null, replaceRes);\n    });\n  });\n};\n\n/**\n * Inserts an item to the beginning of a queue document.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param value\n * The value to store within the list.\n * @param {Object} [options]\n *  @param {boolean} [options.createQueue=false]\n *  Creates the document if it does not already exist.\n *  @param {number} [options.expiry=0]\n *  Set the initial expiration time for the document.  A value of 0 represents\n *  never expiring.\n *  @param {number} [options.persist_to=0]\n *  Ensures this operation is persisted to this many nodes\n *  @param {number} [options.replicate_to=0]\n *  Ensures this operation is replicated to this many nodes\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.queuePush = function(key, value, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  var listOptions = {};\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      listOptions[i] = options[i];\n    }\n  }\n  listOptions.createList = listOptions.createQueue;\n\n  return this.listPrepend(key, value, options, callback);\n};\n\n/**\n * Removes the next item from a queue and returns it.\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.5\n * @committed\n */\nBucket.prototype.queuePop = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  var self = this;\n\n  self.lookupIn(key, options).get('[-1]').execute(function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    var removeOpts = {};\n    for (var j in options) {\n      if (options.hasOwnProperty(j)) {\n        removeOpts[j] = options[j];\n      }\n    }\n\n    if (removeOpts.cas === undefined) {\n      removeOpts.cas = res.cas;\n    }\n\n    var poppedValue = res.contentByIndex(0);\n\n    self.mutateIn(key, removeOpts).remove('[-1]').execute(function(err, res) {\n      if (err) {\n        if (err.code === errors.keyAlreadyExists && options.cas === undefined) {\n          self.queuePop(key, options, callback);\n          return;\n        }\n\n        callback(err, null);\n        return;\n      }\n\n      callback(null, {\n        cas: res.cas,\n        value: poppedValue,\n        token: res.token\n      });\n    });\n  });\n};\n\n/**\n * Returns the current number of items in a queue.\n * PERFORMANCE NOTICE: This currently performs a full document fetch...\n *\n * @param {string|Buffer} key\n * The target document key.\n * @param {Object} [options]\n * @param {Bucket.OpCallback} callback\n *\n * @since 2.2.3\n * @committed\n */\nBucket.prototype.queueSize = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  this.get(key, options, function(err, res) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    res.value = res.value.length;\n    callback(null, res);\n  });\n};\n\n/**\n * @class\n * Represents multiple chunks of a full Document.\n *\n * @private\n *\n * @since 2.1.4\n * @committed\n */\nfunction DocumentFragment(data, paths) {\n  if (data) {\n    this.cas = data.cas;\n    this.contents = data.results;\n  } else {\n    this.cas = null;\n    this.contents = [];\n  }\n  this.pathMap = null;\n  this.indexMap = null;\n\n  for (var i = 0; i < this.contents.length; ++i) {\n    this.contents[i].path = paths[this.contents[i].id];\n  }\n}\n\nDocumentFragment.prototype._contentByIndex = function(index) {\n  if (!(index >= 0 && index < this.contents.length)) {\n    throw new Error('Referenced item does not exist in result.');\n  }\n\n  var item = this.contents[index];\n  if (item.error) {\n    throw item.error;\n  }\n  return item.value;\n};\n\n/**\n * Retrieve the value of the operation by its index. The index is the position\n * of the operation as it was added to the builder.\n *\n * @param {number} index\n *\n * @since 2.1.4\n * @committed\n */\nDocumentFragment.prototype.contentByIndex = function(index) {\n  if (!this.indexMap) {\n    this.indexMap = {};\n    for (var i = 0; i < this.contents.length; ++i) {\n      this.indexMap[this.contents[i].id] = i;\n    }\n  }\n\n  return this._contentByIndex(this.indexMap[index]);\n};\n\n/**\n * Retrieve the value of the operation by its path. The path is the path\n * provided to the operation\n *\n * @param {string} path\n *\n * @since 2.1.4\n * @committed\n */\nDocumentFragment.prototype.content = function(path) {\n  if (!this.pathMap) {\n    this.pathMap = {};\n    for (var i = 0; i < this.contents.length; ++i) {\n      this.pathMap[this.contents[i].path] = i;\n    }\n  }\n\n  return this._contentByIndex(this.pathMap[path]);\n};\n\n/**\n * Checks whether the indicated path exists in this DocumentFragment and no\n * errors were returned from the server.\n *\n * @param {string} path\n *\n * @since 2.1.4\n * @committed\n */\nDocumentFragment.prototype.exists = function(path) {\n  try {\n    this.contents(path);\n    return true;\n  } catch(e) {\n    return false;\n  }\n};\n\n/**\n * @class\n * Builder used to create a set of sub-document lookup operations.\n *\n * @private\n *\n * @since 2.1.4\n * @committed\n */\nfunction LookupInBuilder(bucket, data) {\n  this.bucket = bucket;\n  this.data = data;\n  this.opPaths = [];\n}\n\nLookupInBuilder.prototype._addOp = function() {\n  this.data.push.apply(this.data, arguments);\n  this.opPaths.push(arguments[1]);\n  return this;\n};\n\n/**\n * Indicate a path to be retrieved from the document.  The value of the path\n * can later be retrieved (after .execute()) using the content or contentByIndex\n * method. The path syntax follows N1QL's path syntax (e.g. `foo.bar.baz`).\n *\n * @param {string} path\n * @returns {LookupInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nLookupInBuilder.prototype.get = function(path) {\n  return this._addOp(binding.Constants.SDCMD_GET, path);\n};\n\n/**\n * Similar to get(), but does not actually retrieve the value from the server.\n * This may save bandwidth if you only need to check for the existence of a\n * path (without caring for its content). You can check the status of this\n * operation by using .content (and ignoring the value) or .exists()\n *\n * @param {string} path\n * @returns {LookupInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nLookupInBuilder.prototype.exists = function(path) {\n  return this._addOp(binding.Constants.SDCMD_EXISTS, path);\n};\n\n/**\n * Executes this set of lookup operations on the bucket.\n *\n * @param callback\n *\n * @since 2.1.4\n * @committed\n */\nLookupInBuilder.prototype.execute = function(callback) {\n  return this.bucket._lookupIn(this, callback);\n};\n\n/**\n * Creates a sub-document lookup operation builder.\n *\n * @param {string} key\n * @param {Object} [options]\n *\n * @returns {LookupInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nBucket.prototype.lookupIn = function(key, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object if set.');\n  }\n  this._checkHashkeyOption(options);\n\n  return new LookupInBuilder(this, [key, options.hashkey]);\n};\n\nBucket.prototype._lookupIn = function(builder, callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('Execute argument needs to be a callback.');\n  }\n\n  var data = builder.data.concat([function(err, res) {\n    callback(err, new DocumentFragment(res, builder.opPaths));\n  }]);\n  this._maybeInvoke(this._cb.lookupIn, data);\n};\n\n/**\n * @class\n * Builder used to create a set of sub-document mutation operations.\n *\n * @private\n *\n * @since 2.1.4\n * @committed\n */\nfunction MutateInBuilder(bucket, data) {\n  this.bucket = bucket;\n  this.data = data;\n  this.opPaths = [];\n}\n\nMutateInBuilder.prototype._addOp = function() {\n  this.data.push.apply(this.data, arguments);\n  this.opPaths.push(arguments[1]);\n  return this;\n};\n\n/**\n * Adds an insert operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @param {boolean} createParents\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.insert = function(path, value, createParents) {\n  return this._addOp(binding.Constants.SDCMD_DICT_ADD,\n      path, value, createParents);\n};\n\n/**\n * Adds an upsert operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @param {boolean} createParents\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.upsert = function(path, value, createParents) {\n  return this._addOp(binding.Constants.SDCMD_DICT_UPSERT,\n      path, value, createParents);\n};\n\n/**\n * Adds an replace operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.replace = function(path, value) {\n  return this._addOp(binding.Constants.SDCMD_REPLACE, path, value);\n};\n\n/**\n * Adds an remove operation to this mutation operation set.\n *\n * @param {string} path\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.remove = function(path) {\n  return this._addOp(binding.Constants.SDCMD_REMOVE, path);\n};\n\n/**\n * Adds an array push front operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @param {boolean} createParents\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.arrayPrepend = function(path, value, createParents) {\n  return this._addOp(binding.Constants.SDCMD_ARRAY_ADD_FIRST,\n      path, value, createParents);\n};\n\n/**\n * @deprecated\n * Alias for arrayPrepend\n */\nMutateInBuilder.prototype.pushFront = MutateInBuilder.prototype.arrayPrepend;\n\n/**\n * Adds an array push back operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @param {boolean} createParents\n * @returns {MutateInBuilder}\n *\n * @since 2.2.1\n * @committed\n */\nMutateInBuilder.prototype.arrayAppend = function(path, value, createParents) {\n  return this._addOp(binding.Constants.SDCMD_ARRAY_ADD_LAST,\n      path, value, createParents);\n};\n\n/**\n * @deprecated\n * Alias for arrayAppend\n */\nMutateInBuilder.prototype.pushBack = MutateInBuilder.prototype.arrayAppend;\n\n/**\n * Adds an array insert operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.arrayInsert = function(path, value) {\n  return this._addOp(binding.Constants.SDCMD_ARRAY_INSERT, path, value);\n};\n\n/**\n * Adds an array add unique operation to this mutation operation set.\n *\n * @param {string} path\n * @param {Object} value\n * @param {boolean} createParents\n * @returns {MutateInBuilder}\n *\n * @since 2.2.1\n * @committed\n */\nMutateInBuilder.prototype.arrayAddUnique =\n    function(path, value, createParents) {\n  return this._addOp(binding.Constants.SDCMD_ARRAY_ADD_UNIQUE,\n      path, value, createParents);\n};\n\n/**\n * @deprecated\n * Alias for arrayAddUnique\n */\nMutateInBuilder.prototype.addUnique = MutateInBuilder.prototype.arrayAddUnique;\n\n/**\n * Adds a count operation to this mutation operation set.\n *\n * @param {string} path\n * @param {number} delta\n * @param {boolean} createParents\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.counter = function(path, delta, createParents) {\n  return this._addOp(binding.Constants.SDCMD_COUNTER,\n      path, delta, createParents);\n};\n\n/**\n * Executes this set of mutation operations on the bucket.\n *\n * @param callback\n *\n * @since 2.1.4\n * @committed\n */\nMutateInBuilder.prototype.execute = function(callback) {\n  return this.bucket._mutateIn(this, callback);\n};\n\n/**\n * Creates a sub-document mutation operation builder.\n *\n * @param {string} key\n * @param {Object} [options]\n *\n * @returns {MutateInBuilder}\n *\n * @since 2.1.4\n * @committed\n */\nBucket.prototype.mutateIn = function(key, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object if set.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkExpiryOption(options);\n  this._checkCasOption(options);\n\n  return new MutateInBuilder(this,\n      [key, options.hashkey, options.expiry, options.cas]);\n};\n\nBucket.prototype._mutateIn = function(builder, callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('Execute argument needs to be a callback.');\n  }\n\n  var data = builder.data.concat([function(err, res) {\n    callback(err, new DocumentFragment(res, builder.opPaths));\n  }]);\n  this._maybeInvoke(this._cb.mutateIn, data);\n};\n\n/**\n * Gets or sets the operation timeout in milliseconds. The operation timeout\n * is the time that Bucket will wait for a response from the server for a CRUD\n * operation. If the response is not received within this time frame, the\n * operation is failed with an error.\n *\n * @member {number} Bucket#operationTimeout\n * @default 2500\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'operationTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_OP_TIMEOUT);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_OP_TIMEOUT, val);\n  }\n});\n\n/**\n * Gets or sets the view timeout in milliseconds. The view timeout is the\n * time that Bucket will wait for a response from the server for a view request.\n * If the response is not received within this time frame, the request fails\n * with an error.\n *\n * @member {number} Bucket#viewTimeout\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'viewTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_VIEW_TIMEOUT);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_VIEW_TIMEOUT, val);\n  }\n});\n\n/**\n * Gets or sets the n1ql timeout in milliseconds. The n1ql timeout is the\n * time that Bucket will wait for a response from the server for a n1ql request.\n * If the response is not received within this time frame, the request fails\n * with an error.\n *\n * @member {number} Bucket#n1qlTimeout\n *\n * @since 2.1.5\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'n1qlTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_N1QL_TIMEOUT);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_N1QL_TIMEOUT, val);\n  }\n});\n\n/**\n * Gets or sets the durability timeout in milliseconds. The durability timeout\n * is the time that Bucket will wait for a response from the server in regards\n * to a durability request.  If there are no responses received within this time\n * frame, the request fails with an error.\n *\n * @member {number} Bucket#durabilityTimeout\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'durabilityTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_DURABILITY_TIMEOUT);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_DURABILITY_TIMEOUT, val);\n  }\n});\n\n/**\n * Gets or sets the durability interval in milliseconds. The durability\n * interval is the time that Bucket will wait between requesting new durability\n * information during a durability poll.\n *\n * @member {number} Bucket#durabilityInterval\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'durabilityInterval', {\n  get: function() {\n    return this._ctl(CONST.CNTL_DURABILITY_INTERVAL);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_DURABILITY_INTERVAL, val);\n  }\n});\n\n/**\n * Gets or sets the management timeout in milliseconds. The management timeout\n * is the time that Bucket will wait for a response from the server for a\n * management request.  If the response is not received within this time frame,\n * the request is failed out with an error.\n *\n * @member {number} Bucket#managementTimeout\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'managementTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_HTTP_TIMEOUT);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_HTTP_TIMEOUT, val);\n  }\n});\n\n/**\n * Gets or sets the config throttling in milliseconds. The config throttling is\n * the time that Bucket will wait before forcing a configuration refresh.  If no\n * refresh occurs before this period while a configuration is marked invalid,\n * an update will be triggered.\n *\n * @member {number} Bucket#configThrottle\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'configThrottle', {\n  get: function() {\n    return this._ctl(CONST.CNTL_CONFDELAY_THRESH);\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_CONFDELAY_THRESH, val);\n  }\n});\n\n/**\n * Sets or gets the connection timeout in milliseconds. This is the timeout\n * value used when connecting to the configuration port during the initial\n * connection (in this case, use this as a key in the 'options' parameter in\n * the constructor) and/or when Bucket attempts to reconnect in-situ (if the\n * current connection has failed).\n *\n * @member {number} Bucket#connectionTimeout\n * @default 5000\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'connectionTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_CONFIGURATION_TIMEOUT );\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_CONFIGURATION_TIMEOUT, val);\n  }\n});\n\n/**\n * Sets or gets the node connection timeout in msecs. This value is similar to\n * {@link Bucket#connectionTimeout}, but defines the time to wait for a\n * particular node to respond before trying the next one.\n *\n * @member {number} Bucket#nodeConnectionTimeout\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'nodeConnectionTimeout', {\n  get: function() {\n    return this._ctl(CONST.CNTL_CONFIG_NODE_TIMEOUT );\n  },\n  set: function(val) {\n    this._ctl(CONST.CNTL_CONFIG_NODE_TIMEOUT, val);\n  }\n});\n\n/**\n * Returns the libcouchbase version as a string.  This information will usually\n * be in the format of 2.4.0-fffffff representing the major, minor, patch and\n * git-commit that the built libcouchbase is based upon.\n *\n * @member {string} Bucket#lcbVersion\n *\n * @example\n * \"2.4.0-beta.adbf222\"\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'lcbVersion', {\n  get: function() {\n    return this._cb.lcbVersion();\n  },\n  writeable: false\n});\n\n/**\n * Returns the version of the Node.js library as a string.\n *\n * @member {string} Bucket#clientVersion\n *\n * @example\n * \"2.0.0-beta.fa123bd\"\n *\n * @since 2.0.0\n * @committed\n */\nObject.defineProperty(Bucket.prototype, 'clientVersion', {\n  get: function() {\n    var pkgJson = fs.readFileSync(\n      path.resolve(__dirname, '../package.json'));\n    return JSON.parse(pkgJson).version;\n  },\n  writeable: false\n});\n\nmodule.exports = Bucket;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/errors.js":"'use strict';\n\nvar binding = require('./binding');\n\nvar CONST = binding.Constants;\n\n/**\n * Enumeration of all error codes.  See libcouchbase documentation\n * for more details on what these errors represent.\n *\n * @global\n * @readonly\n * @enum {number}\n */\nmodule.exports = {\n  /** Operation was successful **/\n  success: CONST.SUCCESS,\n\n  /** Authentication should continue. **/\n  authContinue: CONST.AUTH_CONTINUE,\n\n  /** Error authenticating. **/\n  authError: CONST.AUTH_ERROR,\n\n  /** The passed incr/decr delta was invalid. **/\n  deltaBadVal: CONST.DELTA_BADVAL,\n\n  /** Object is too large to be stored on the cluster. **/\n  objectTooBig: CONST.E2BIG,\n\n  /** Server is too busy to handle your request right now. **/\n  serverBusy: CONST.EBUSY,\n\n  /** Internal libcouchbase error. **/\n  cLibInternal: CONST.EINTERNAL,\n\n  /** An invalid arguement was passed. **/\n  cLibInvalidArgument: CONST.EINVAL,\n\n  /** The server is out of memory. **/\n  cLibOutOfMemory: CONST.ENOMEM,\n\n  /** An invalid range was specified. **/\n  invalidRange: CONST.ERANGE,\n\n  /** An unknown error occured within libcouchbase. **/\n  cLibGenericError: CONST.ERROR,\n\n  /** A temporary error occured. Try again. **/\n  temporaryError: CONST.ETMPFAIL,\n\n  /** The key already exists on the server. **/\n  keyAlreadyExists: CONST.KEY_EEXISTS,\n\n  /** The key does not exist on the server. **/\n  keyNotFound: CONST.KEY_ENOENT,\n\n  /** Failed to open library. **/\n  failedToOpenLibrary: CONST.DLOPEN_FAILED,\n\n  /** Failed to find expected symbol in library. **/\n  failedToFindSymbol: CONST.DLSYM_FAILED,\n\n  /** A network error occured. **/\n  networkError: CONST.NETWORK_ERROR,\n\n  /** Operations were performed on the incorrect server. **/\n  wrongServer: CONST.NOT_MY_VBUCKET,\n\n  /** Operations were performed on the incorrect server. **/\n  notMyVBucket: CONST.NOT_MY_VBUCKET,\n\n  /** The document was not stored. */\n  notStored: CONST.NOT_STORED,\n\n  /** An unsupported operation was sent to the server. **/\n  notSupported: CONST.NOT_SUPPORTED,\n\n  /** An unknown command was sent to the server. **/\n  unknownCommand: CONST.UNKNOWN_COMMAND,\n\n  /** An unknown host was specified. **/\n  unknownHost: CONST.UNKNOWN_HOST,\n\n  /** A protocol error occured. **/\n  protocolError: CONST.PROTOCOL_ERROR,\n\n  /** The operation timed out. **/\n  timedOut: CONST.ETIMEDOUT,\n\n  /** Error connecting to the server. **/\n  connectError: CONST.CONNECT_ERROR,\n\n  /** The bucket you request was not found. **/\n  bucketNotFound: CONST.BUCKET_ENOENT,\n\n  /** libcouchbase is out of memory. **/\n  clientOutOfMemory: CONST.CLIENT_ENOMEM,\n\n  /** A temporary error occured in libcouchbase. Try again. **/\n  clientTemporaryError: CONST.CLIENT_ETMPFAIL,\n\n  /** A bad handle was passed. */\n  badHandle: CONST.EBADHANDLE,\n\n  /** A server bug caused the operation to fail. **/\n  serverBug: CONST.SERVER_BUG,\n\n  /** The host format specified is invalid. **/\n  invalidHostFormat: CONST.INVALID_HOST_FORMAT,\n\n  /** Not enough nodes to meet the operations durability requirements. **/\n  notEnoughNodes: CONST.DURABILITY_ETOOMANY,\n\n  /** Duplicate items. **/\n  duplicateItems: CONST.DUPLICATE_COMMANDS,\n\n  /** Key mapping failed and could not match a server. **/\n  noMatchingServerForKey: CONST.NO_MATCHING_SERVER,\n\n  /** A bad environment variable was specified. **/\n  badEnvironmentVariable: CONST.BAD_ENVIRONMENT,\n\n  /** Couchnode is out of memory. **/\n  outOfMemory: CONST['ErrorCode::MEMORY'],\n\n  /** Invalid arguements were passed. **/\n  invalidArguments: CONST['ErrorCode::ARGUMENTS'],\n\n  /** An error occured while trying to schedule the operation. **/\n  schedulingError: CONST['ErrorCode::SCHEDULING'],\n\n  /** Not all operations completed successfully. **/\n  checkResults: CONST['ErrorCode::CHECK_RESULTS'],\n\n  /** A generic error occured in Couchnode. **/\n  genericError: CONST['ErrorCode::GENERIC'],\n\n  /** The specified durability requirements could not be satisfied. **/\n  durabilityFailed: CONST['ErrorCode::DURABILITY_FAILED'],\n\n  /** An error occured during a RESTful operation. **/\n  restError: CONST['ErrorCode::REST']\n};\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/viewquery.js":"'use strict';\n\nvar util = require('util');\n\n/**\n * Class for dynamically construction of view queries.  This class should\n * never be constructed directly, instead you should use\n * {@link ViewQuery.from} to construct this object.\n *\n * @constructor\n *\n * @since 2.0.1\n * @committed\n *\n * @private\n */\nfunction ViewQuery() {\n  this.ddoc = null;\n  this.name = null;\n  this.options = {};\n}\n\n/**\n * Enumeration for specifying view update semantics.\n *\n * @readonly\n * @enum {number}\n */\nViewQuery.Update = {\n  /**\n   * Causes the view to be fully indexed before results are retrieved.\n   */\n  BEFORE: 1,\n\n  /**\n   * Allows the index to stay in whatever state it is already in prior\n   * retrieval of the query results.\n   */\n  NONE: 2,\n\n  /**\n   * Forces the view to be indexed after the results of this query has\n   * been fetched.\n   */\n  AFTER: 3\n};\n\n/**\n * Enumeration for specifying view result ordering.\n *\n * @readonly\n * @enum {number}\n */\nViewQuery.Order = {\n  /**\n   * Orders with lower values first and higher values last.\n   */\n  ASCENDING: 1,\n\n  /**\n   * Orders with higher values first and lower values last.\n   */\n  DESCENDING: 2\n};\n\n/**\n * Enumeration for specifying on_error behaviour.\n *\n * @readonly\n * @enum {number}\n */\nViewQuery.ErrorMode = {\n  /**\n   * Continues querying when an error occurs.\n   */\n  CONTINUE: 1,\n\n  /**\n   * Stops and errors query when an error occurs.\n   */\n  STOP: 2\n};\n\n/**\n * Specifies the design document and view name to use for this query.\n *\n * @param {string} ddoc The design document to use.\n * @param {string} name The view to use.\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.from = function(ddoc, name) {\n  this.ddoc = ddoc;\n  this.name = name;\n  return this;\n};\n\n/**\n * Specifies how this query will affect view indexing, both before and\n * after the query is executed.\n *\n * @param {ViewQuery.Update} stale How to update the index.\n * @default ViewQuery.Update.NONE\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.stale = function(stale) {\n  if (stale === ViewQuery.Update.BEFORE) {\n    this.options.stale = 'false';\n  } else if (stale === ViewQuery.Update.NONE) {\n    this.options.stale = 'ok';\n  } else if (stale === ViewQuery.Update.AFTER) {\n    this.options.stale = 'update_after';\n  } else {\n    throw new TypeError('invalid option passed.');\n  }\n  return this;\n};\n\n/**\n * Specifies how many results to skip from the beginning of the result set.\n *\n * @param {number} skip\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.skip = function(skip) {\n  this.options.skip = skip;\n  return this;\n};\n\n/**\n * Specifies the maximum number of results to return.\n *\n * @param {number} limit\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.limit = function(limit) {\n  this.options.limit = limit;\n  return this;\n};\n\n/**\n * Allows you to specify custom view options that may not be available\n * though the fluent interface defined by this class.\n *\n * @param {Object} opts\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.custom = function(opts) {\n  for (var i in opts) {\n    /* istanbul ignore else */\n    if (opts.hasOwnProperty(i)) {\n      this.options[i] = opts[i];\n    }\n  }\n  return this;\n};\n\n/**\n * Specifies the desired ordering for the results.\n *\n * @param {ViewQuery.Order} order\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.order = function(order) {\n  if (order === ViewQuery.Order.ASCENDING) {\n    this.options.descending = false;\n  } else if (order === ViewQuery.Order.DESCENDING) {\n    this.options.descending = true;\n  } else {\n    throw new TypeError('invalid option passed.');\n  }\n  return this;\n};\n\n/**\n * Specifies whether to execute the map-reduce reduce step.\n *\n * @param {boolean} reduce\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.reduce = function(reduce) {\n  this.options.reduce = reduce;\n  return this;\n};\n\n/**\n * Specifies whether to preform grouping during view execution.\n *\n * @param {boolean} group\n * @returns {ViewQuery}\n *\n * @since 2.0.3\n * @committed\n */\nViewQuery.prototype.group = function(group) {\n  if (group === undefined || group === true) {\n    this.options.group = true;\n  } else if (group === false) {\n    this.options.group = false;\n    \n  // For backwards compatibility\n  } else if (group >= 0) {\n    this.options.group = false;\n    this.options.group_level = group;\n  } else {\n    this.options.group = true;\n    this.options.group_level = 0;\n  }\n  return this;\n};\n\n/**\n * Specifies the level at which to perform view grouping.\n *\n * @param {number} group_level\n * @returns {ViewQuery}\n *\n * @since 2.0.3\n * @committed\n */\nViewQuery.prototype.group_level  = function(group_level) {\n  if (group_level !== undefined) {\n    this.options.group_level = group_level;\n  } else {\n    delete this.options.group_level;\n  }\n  return this;\n};\n\n/**\n * Specifies a specified key to retrieve from the index.\n *\n * @param {string} key\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.key = function(key) {\n  this.options.key = JSON.stringify(key);\n  return this;\n};\n\n/**\n * Specifies a list of keys you wish to retrieve from the index.\n *\n * @param {Array.<string>} keys\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.keys = function(keys) {\n  this.options.keys = JSON.stringify(keys);\n  return this;\n};\n\n/**\n * Specifies a range of keys to retrieve from the index.  You may specify both\n * a start and an end point and additionally specify whether or not the end\n * value is inclusive or exclusive.\n *\n * @param {string|Array.<string>|undefined} start\n * @param {string|Array.<string>|undefined} end\n * @param {boolean} [inclusive_end]\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.range = function(start, end, inclusive_end) {\n  this.options.startkey = JSON.stringify(start);\n  this.options.endkey = JSON.stringify(end);\n  if (inclusive_end) {\n    this.options.inclusive_end = 'true';\n  } else {\n    delete this.options.inclusive_end;\n  }\n  return this;\n};\n\n/**\n * Specifies a range of document id's to retrieve from the index.\n *\n * @param {string|undefined} start\n * @param {string|undefined} end\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.prototype.id_range = function(start, end) {\n  this.options.startkey_docid = start;\n  this.options.endkey_docid = end;\n  return this;\n};\n\n/**\n * Flag to request a view request include the full document value.\n *\n * @param {boolean} include_docs\n * @returns {ViewQuery}\n *\n * @since 2.0.8\n * @committed\n */\nViewQuery.prototype.include_docs = function(include_docs) {\n  if (include_docs === undefined || include_docs) {\n    this.options.include_docs = 'true';\n  } else {\n    delete this.options.include_docs;\n  }\n  return this;\n};\n\n/**\n * Flag to request a view request accross all nodes in the case of\n * a development view.\n *\n * @param {boolean} full_set\n * @returns {ViewQuery}\n *\n * @since 2.0.3\n * @committed\n */\nViewQuery.prototype.full_set = function(full_set) {\n  if (full_set === undefined || full_set) {\n    this.options.full_set = 'true';\n  } else {\n    delete this.options.full_set;\n  }\n  return this;\n};\n\n/**\n * Sets the error handling mode for this query.\n *\n * @param {ViewQuery.ErrorMode} mode\n * @returns {ViewQuery}\n *\n * @since 2.0.3\n * @committed\n */\nViewQuery.prototype.on_error = function(mode) {\n  if (mode === ViewQuery.ErrorMode.CONTINUE) {\n    this.options.on_error = 'continue';\n  } else if (mode === ViewQuery.ErrorMode.STOP) {\n    this.options.on_error = 'stop';\n  } else {\n    throw new TypeError('invalid option passed.');\n  }\n  return this;\n};\n\n/**\n * Instantiates a {@link ViewQuery} object for the specified design\n * document and view name.\n *\n * @param {string} ddoc The design document to use.\n * @param {string} name The view to use.\n * @returns {ViewQuery}\n *\n * @since 2.0.0\n * @committed\n */\nViewQuery.from = function(ddoc, name) {\n  return (new ViewQuery()).from(ddoc, name);\n};\n\n// For backwards compatibility with 2.0.0\nvar SpatialQuery = require('./spatialquery');\nViewQuery.fromSpatial = SpatialQuery.from;\nViewQuery.Default = ViewQuery;\nViewQuery.Spatial = SpatialQuery;\n\nmodule.exports = ViewQuery;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/spatialquery.js":"'use strict';\n\nvar util = require('util');\n\n/**\n * Class for dynamically construction of spatial queries.  This class should\n * never be constructed directly, instead you should use\n * {@link SpatialQuery.from} to construct this object.\n *\n * @constructor\n *\n * @since 2.0.1\n * @committed\n *\n * @private\n */\nfunction SpatialQuery() {\n  this.ddoc = null;\n  this.name = null;\n  this.options = {};\n}\n\n/**\n * Enumeration for specifying view update semantics.\n *\n * @readonly\n * @enum {number}\n */\nSpatialQuery.Update = {\n  /**\n   * Causes the view to be fully indexed before results are retrieved.\n   */\n  BEFORE: 1,\n\n  /**\n   * Allows the index to stay in whatever state it is already in prior\n   * retrieval of the query results.\n   */\n  NONE: 2,\n\n  /**\n   * Forces the view to be indexed after the results of this query has\n   * been fetched.\n   */\n  AFTER: 3\n};\n\n/**\n * Specifies the design document and view name to use for this query.\n *\n * @param {string} ddoc The design document to use.\n * @param {string} name The view to use.\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.prototype.from = function(ddoc, name) {\n  this.ddoc = ddoc;\n  this.name = name;\n  return this;\n};\n\n/**\n * Specifies how this query will affect view indexing, both before and\n * after the query is executed.\n *\n * @param {SpatialQuery.Update} stale How to update the index.\n * @default SpatialQuery.Update.NONE\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.prototype.stale = function(stale) {\n  if (stale === SpatialQuery.Update.BEFORE) {\n    this.options.stale = 'false';\n  } else if (stale === SpatialQuery.Update.NONE) {\n    this.options.stale = 'ok';\n  } else if (stale === SpatialQuery.Update.AFTER) {\n    this.options.stale = 'update_after';\n  } else {\n    throw new TypeError('invalid option passed.');\n  }\n  return this;\n};\n\n/**\n * Specifies how many results to skip from the beginning of the result set.\n *\n * @param {number} skip\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.prototype.skip = function(skip) {\n  this.options.skip = skip;\n  return this;\n};\n\n/**\n * Specifies the maximum number of results to return.\n *\n * @param {number} limit\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.prototype.limit = function(limit) {\n  this.options.limit = limit;\n  return this;\n};\n\n/**\n * Specifies a bounding box to query the index for.  This value must be an\n * array of exactly 4 numbers which represents the left, top, right and\n * bottom edges of the bounding box (in that order).\n *\n * @param {Array.<number>} bbox\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.prototype.bbox = function(bbox) {\n  this.options.bbox = bbox.join(',');\n  return this;\n};\n\n/**\n * Allows you to specify custom view options that may not be available\n * though the fluent interface defined by this class.\n *\n * @param {Object} opts\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.prototype.custom = function(opts) {\n  for (var i in opts) {\n    /* istanbul ignore else */\n    if (opts.hasOwnProperty(i)) {\n      this.options[i] = opts[i];\n    }\n  }\n  return this;\n};\n\n/**\n * Instantiates a {@link SpatialQuery} object for the specified design\n * document and view name.\n *\n * @param {string} ddoc The design document to use.\n * @param {string} name The view to use.\n * @returns {SpatialQuery}\n *\n * @since 2.0.0\n * @committed\n */\nSpatialQuery.from = function(ddoc, name) {\n  return (new SpatialQuery()).from(ddoc, name);\n};\n\nmodule.exports = SpatialQuery;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/n1qlquery.js":"'use strict';\n\nvar util = require('util');\nvar qs = require('querystring');\n\n/**\n * Class for dynamically construction of N1QL queries.  This class should never\n * be constructed directly, instead you should use the\n * {@link N1qlQuery.fromString} static method to instantiate a\n * {@link N1qlStringQuery}.\n *\n * @constructor\n *\n * @since 2.0.0\n * @committed\n */\nfunction N1qlQuery() {\n}\n\n/**\n * Enumeration for specifying N1QL consistency semantics.\n *\n * @readonly\n * @enum {number}\n */\nN1qlQuery.Consistency = {\n  /**\n   * This is the default (for single-statement requests).\n   */\n  NOT_BOUNDED: 1,\n\n  /**\n   * This implements strong consistency per request.\n   */\n  REQUEST_PLUS: 2,\n\n  /**\n   * This implements strong consistency per statement.\n   */\n  STATEMENT_PLUS: 3\n};\n\n/**\n * Returns the fully prepared string representation of this query.\n */\nN1qlQuery.prototype.toString = function() {\n  throw new Error('Must use N1qlQuery subclasses only.');\n};\n\nmodule.exports = N1qlQuery;\n\n\n/**\n * Class for holding a explicitly defined N1QL query string.\n *\n * @constructor\n * @extends N1qlQuery\n *\n * @since 2.0.0\n * @committed\n */\nfunction N1qlStringQuery(str) {\n  this.options = {\n    statement: str\n  };\n  this.isAdhoc = true;\n}\nutil.inherits(N1qlStringQuery, N1qlQuery);\nN1qlQuery.Direct = N1qlStringQuery;\n\n/**\n * Specify the consistency level for this query.\n *\n * @param {N1qlQuery.Consistency} val\n * @returns {N1qlStringQuery}\n *\n * @since 2.0.10\n * @committed\n */\nN1qlStringQuery.prototype.consistency = function(val) {\n  if (this.options.scan_vectors !== undefined) {\n    throw new Error('consistency and consistentWith must be use exclusively.');\n  }\n\n  if (val === N1qlQuery.Consistency.NOT_BOUNDED) {\n    this.options.scan_consistency = 'not_bounded';\n  } else if (val === N1qlQuery.Consistency.REQUEST_PLUS) {\n    this.options.scan_consistency = 'request_plus';\n  } else if (val === N1qlQuery.Consistency.STATEMENT_PLUS) {\n    this.options.scan_consistency = 'statement_plus';\n  } else {\n    throw new TypeError('invalid option passed.');\n  }\n  return this;\n};\n\n/**\n * Specifies a MutationState object to ensure this query is\n * consistent with.\n *\n * @param state\n *\n * @since 2.1.7\n * @committed\n */\nN1qlStringQuery.prototype.consistentWith = function(state) {\n  if (this.options.scan_consistency !== undefined) {\n    throw new Error('consistency and consistentWith must be use exclusively.');\n  }\n\n  this.options.scan_consistency = 'at_plus';\n  this.options.scan_vectors = state;\n};\n\n/**\n * Specifies whether this query is adhoc or should\n * be prepared.\n *\n * @param {boolean} adhoc\n * @returns {N1qlStringQuery}\n *\n * @since 2.1.0\n * @committed\n */\nN1qlStringQuery.prototype.adhoc = function(adhoc) {\n  this.isAdhoc = !!adhoc;\n  return this;\n};\n\n/**\n * Specifies enable/disable formatting a query result\n *\n * @param {boolean} pretty\n * @returns {N1qlStringQuery}\n *\n * @since 4.5.1\n */\nN1qlStringQuery.prototype.pretty = function(pretty) {\n  this.options.pretty = !!pretty;\n  return this;\n};\n\n/**\n * Returns the fully prepared string representation of this query.\n */\nN1qlStringQuery.prototype.toString = function(args) {\n  return qs.stringify(this.toObject(args));\n};\n\n/**\n * Returns the fully prepared object representation of this query.\n */\nN1qlStringQuery.prototype.toObject = function(args) {\n  if (!args) {\n    return this.options;\n  }\n\n  var out = {};\n  for (var i in this.options) {\n    if (this.options.hasOwnProperty(i)) {\n      out[i] = this.options[i];\n    }\n  }\n\n  if (Array.isArray(args)) {\n    out.args = args;\n  } else {\n    for (var j in args) {\n      if (args.hasOwnProperty(j)) {\n        out['$' + j] = args[j];\n      }\n    }\n  }\n\n  return out;\n};\n\n/**\n * Creates a query object directly from the passed query string.\n *\n * @param {string} str The N1QL query string.\n * @returns {N1qlStringQuery}\n *\n * @since 2.0.0\n * @committed\n */\nN1qlQuery.fromString = function(str) {\n  return new N1qlStringQuery(str);\n};\n\n/*\nfunction N1qlSelectQuery() {\n  this.from = null;\n  this.fields = null;\n  this.cond = null;\n}\nutil.inherits(N1qlSelectQuery, N1qlQuery);\n\nN1qlQuery.from = function(collection) {\n  return (new N1qlSelectQuery()).from(collection);\n};\n\nN1qlSelectQuery.prototype.select = function() {\n  this.fields = [];\n  for (var i = 0; i < arguments.length; ++i) {\n    this.fields.push(arguments[i]);\n  }\n  return this;\n};\n\nN1qlSelectQuery.prototype.where = function(expr) {\n  this.cond = expr;\n  return this;\n};\n\nN1qlSelectQuery.prototype.toString = function() {\n  var out = '';\n  out += 'FROM ';\n  out += this.from;\n  out += ' SELECT ';\n  for (var i = 0; i < this.fields.length; ++i) {\n    if (i !== 0) {\n      out += ', ';\n    }\n    out += this.fields[i].toString();\n  }\n  if (this.cond) {\n    out += ' WHERE ';\n    out += this.cond.toString();\n  }\n  return out;\n};\n\n\n\nvar _xReset = function(expr) {\n  expr.root = expr;\n  expr.type = 'unknown';\n  expr.val = null;\n  expr.left = null;\n  expr.right = null;\n};\n\nvar N1qlExpr = function(val) {\n  _xReset(this, val);\n};\n\nvar _N1qlLiteral = function(val) {\n  if (val instanceof N1qlExpr) {\n    return val;\n  } else {\n    var n = new N1qlExpr(val);\n    n.type = 'literal';\n    n.val = val;\n    return n;\n  }\n};\n\nvar _N1qlConstant = function(val) {\n  if (val instanceof N1qlExpr) {\n    return val;\n  } else {\n    var n = new N1qlExpr(val);\n    n.type = 'constant';\n    n.val = val;\n    return n;\n  }\n};\n\nvar _N1qlVariable = function(name) {\n  var n = new N1qlExpr();\n  n.type = 'variable';\n  n.val = name;\n  return n;\n};\n\nvar _xSwap = function(val) {\n  var n = new N1qlExpr();\n  n.root = val.root;\n  n.type = val.type;\n  n.val = val.val;\n  n.left = val.left;\n  n.right = val.right;\n  _xReset(val);\n  return n;\n};\n\nvar _xFunc = function(funcName) {\n  return function() {\n    var n = _xSwap(this);\n    this.type = 'function';\n    this.val = funcName;\n    this.left = [n];\n    return this;\n  };\n};\nN1qlExpr.prototype.round = _xFunc('round');\n\nvar _xArithmetic = function(operator) {\n  return function(val) {\n    var n = _xSwap(this);\n    this.type = 'arithmetic';\n    this.val = operator;\n    this.left = n;\n    this.right = _N1qlConstant(val);\n    return this;\n  };\n};\nN1qlExpr.prototype.add = _xArithmetic('+');\nN1qlExpr.prototype.sub = _xArithmetic('-');\nN1qlExpr.prototype.div = _xArithmetic('/');\nN1qlExpr.prototype.mul = _xArithmetic('*');\nN1qlExpr.prototype.mod = _xArithmetic('%');\n\nvar _xUArithmetic = function(operator) {\n  return function() {\n    var n = _xSwap(this);\n    this.type = 'arithmetic_unary';\n    this.val = operator;\n    this.right = n;\n    return this;\n  };\n};\nN1qlExpr.prototype.neg = _xUArithmetic('-');\n\nvar _xCompare = function(operator) {\n  return function(right) {\n    var n = _xSwap(this);\n    this.type = 'compare';\n    this.val = operator;\n    this.left = n;\n    this.right = _N1qlConstant(right);\n    return this;\n  };\n};\nN1qlExpr.prototype.eq = _xCompare('=');\nN1qlExpr.prototype.ne = _xCompare('!=');\nN1qlExpr.prototype.ltgt = _xCompare('<>');\nN1qlExpr.prototype.gt = _xCompare('>');\nN1qlExpr.prototype.lt = _xCompare('<');\nN1qlExpr.prototype.gte = _xCompare('>=');\nN1qlExpr.prototype.lte = _xCompare('<=');\nN1qlExpr.prototype.like = _xCompare('like');\nN1qlExpr.prototype.notLike = _xCompare('not like');\n\nvar _xUCompare = function(operator) {\n  return function() {\n    var n = _xSwap(this);\n    this.type = 'compare_unary';\n    this.val = operator;\n    this.left = n;\n    return this;\n  };\n};\nN1qlExpr.prototype.isMissing = _xUCompare('is missing');\nN1qlExpr.prototype.isNotMissing = _xUCompare('is not missing');\nN1qlExpr.prototype.isNull = _xUCompare('is null');\nN1qlExpr.prototype.isNotNull = _xUCompare('is not null');\nN1qlExpr.prototype.isValued = _xUCompare('is valued');\nN1qlExpr.prototype.isNotValued = _xUCompare('is not valued');\n\nN1qlExpr.prototype.as = function(name) {\n  this.root.alias = name;\n  return this;\n};\n\nN1qlExpr.prototype.toString = function() {\n  var out = '';\n  if (this.type === 'constant') {\n    if (typeof this.val === 'string') {\n      out = '\"' + this.val + '\"';\n    } else {\n      out = this.val;\n    }\n  } else if (this.type === 'literal') {\n    out = '`' + this.val + '`';\n  } else if (this.type === 'variable') {\n    out = ':' + this.val;\n  } else if (this.type === 'compare') {\n    out = this.left.toString();\n    out += this.val.toUpperCase();\n    out += this.right.toString();\n  } else if (this.type === 'compare_unary') {\n    out = this.left.toString();\n    out += this.val.toUpperCase();\n  } else if (this.type === 'arithmetic') {\n    out = this.left.toString();\n    out += ' ' + this.val.toUpperCase() + ' ';\n    out += this.right.toString();\n  } else if (this.type === 'arithmetic_unary') {\n    out = this.val.toUpperCase();\n    out += this.right.toString();\n  } else if (this.type === 'function') {\n    out = this.val.toUpperCase();\n    out += '(';\n    for (var i = 0; i < this.left.length; ++i) {\n      if (i !== 0) {\n        out += ', ';\n      }\n      out += this.left[i].toString();\n    }\n    out += ')';\n  }\n\n  if (this.alias) {\n    out += ' AS ' + '`' + this.alias + '`';\n  }\n\n  return out;\n};\n\nN1qlQuery.Literal = _N1qlLiteral;\nN1qlQuery.Constant = _N1qlConstant;\nN1qlQuery.Variable = _N1qlVariable;\n*/\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/searchquery.js":"'use strict';\n\nvar util = require('util');\nvar cbutils = require('./utils');\nvar queryProtos = require('./searchquery_queries');\n\n/**\n * Class for building of FTS search queries.  This class should never\n * be constructed directly, instead you should use the {@link SearchQuery.new}\n * static method to instantiate a {@link SearchQuery}.\n *\n * @constructor\n *\n * @since 2.1.7\n * @committed\n */\nfunction SearchQuery(indexName, query) {\n  this.data = {\n    indexName: indexName,\n    query: query\n  };\n}\n\n/**\n * Enumeration for specifying FTS consistency semantics.\n *\n * @readonly\n * @enum {number}\n */\nSearchQuery.Consistency = {\n  /**\n   * This is the default (for single-statement requests).\n   */\n  NOT_BOUNDED: 1\n};\n\n/**\n * Enumeration for specifying FTS highlight styling.\n *\n * @readonly\n * @enum {number}\n */\nSearchQuery.HighlightStyle = {\n  /**\n   * This causes hits to be highlighted using the default style.\n   */\n  DEFAULT: undefined,\n\n  /**\n   * This causes hits to be highlighted using HTML tags.\n   */\n  HTML: 'html',\n\n  /**\n   * This causes hits to be highlighted with ANSI character codes.\n   */\n  ANSI: 'ansi'\n};\n\n/**\n * Specifies how many results to skip from the beginning of the result set.\n *\n * @param {number} skip\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.skip = function(skip) {\n  this.data.from = skip;\n  return this;\n};\n\n/**\n * Specifies the maximum number of results to return.\n *\n * @param {number} limit\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.limit = function(limit) {\n  this.data.size = limit;\n  return this;\n};\n\n/**\n * Includes information about the internal search semantics used\n * to execute your query.\n *\n * @param {boolean} explain\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.explain = function(explain) {\n  this.data.explain = explain;\n  return this;\n};\n\n/**\n * Requests a particular highlight style and field list for this query.\n *\n * @param {SearchQuery.HighlightStyle} style\n * @param {string[]} fields\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.highlight = function(style, fields) {\n  fields = cbutils.unpackArgs(fields, arguments, 1);\n\n  if (!this.data.highlight) {\n    this.data.highlight = {};\n  }\n\n  this.data.highlight.style = style;\n  this.data.highlight.fields = fields;\n  return this;\n};\n\n/**\n * Specifies the fields you wish to receive in the result set.\n *\n * @param {string[]} fields\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.fields = function(fields) {\n  fields = cbutils.unpackArgs(fields, arguments);\n\n  this.data.fields = fields;\n  return this;\n};\n\n/**\n * Specifies the fields you wish to sort by in your result set.\n *\n * @param {string[]} fields\n * @returns {SearchQuery}\n *\n * @since 2.3.0\n * @committed\n */\nSearchQuery.prototype.sort = function(fields) {\n  fields = cbutils.unpackArgs(fields, arguments);\n\n  this.data.sort = fields;\n  return this;\n};\n\n/**\n * Adds a SearchFacet object to return information about as part\n * of the execution of this query.\n *\n * @param {string} name\n * @param {SeachFacet} facet\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.addFacet = function(name, facet) {\n  if (!this.data.facets) {\n    this.data.facets = {};\n  }\n  this.data.facets[name] = facet;\n  return this;\n};\n\n/**\n * Specify the consistency level for this query.\n *\n * @param {SearchQuery.Consistency} val\n * @returns {SearchQuery}\n *\n * @since 2.2.3\n * @committed\n */\nSearchQuery.prototype.consistency = function(val) {\n  if (!this.data.ctl) {\n    this.data.ctl = {};\n  }\n  if (!this.data.ctl.consistency) {\n    this.data.ctl.consistency = {};\n  }\n\n  if (this.data.ctl.consistency.level !== undefined) {\n    throw new Error('consistency and consistentWith must be use exclusively.');\n  }\n\n\n  if (val === SearchQuery.Consistency.NOT_BOUNDED) {\n    this.data.ctl.consistency.level = 'not_bounded';\n  } else {\n    throw new TypeError('invalid option passed.');\n  }\n  return this;\n};\n\n/**\n * Specifies a MutationState object to ensure this query is\n * consistent with.\n *\n * @param state\n *\n * @since 2.2.3\n * @uncommitted\n */\nSearchQuery.prototype.consistentWith = function(state) {\n  if (!this.data.ctl) {\n    this.data.ctl = {};\n  }\n  if (!this.data.ctl.consistency) {\n    this.data.ctl.consistency = {};\n  }\n\n  if (this.data.ctl.consistency.level !== undefined) {\n    throw new Error('consistency and consistentWith must be use exclusively.');\n  }\n\n  this.data.ctl.consistency.level = 'at_plus';\n  this.data.ctl.consistency.vectors = state;\n};\n\n/**\n * Specifies the maximum time to wait (in millseconds) for this\n * query to complete.\n *\n * @param {number} timeout\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.prototype.timeout = function(timeout) {\n  if (!this.data.ctl) {\n    this.data.ctl = {};\n  }\n\n  this.data.ctl.timeout = timeout;\n  return this;\n};\n\nSearchQuery.prototype.toJSON = function() {\n  return this.data;\n};\n\n/**\n * Creates a new search query from an index name and search query definition.\n *\n * @param {string} indexName\n * @param {SearchQuery.Query} query\n * @returns {SearchQuery}\n *\n * @since 2.1.7\n * @committed\n */\nSearchQuery.new = function(indexName, query) {\n  return new SearchQuery(indexName, query);\n};\n\nfor (var i in queryProtos) {\n  if (queryProtos.hasOwnProperty(i)) {\n    SearchQuery[i] = queryProtos[i];\n  }\n}\n\nmodule.exports = SearchQuery;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/utils.js":"'use strict';\n\nfunction unpackArgs(first, args, first_index) {\n  if (!first_index) {\n    first_index = 0;\n  }\n  if (!Array.isArray(first)) {\n    first = [first];\n    for (var i = first_index + 1; i < args.length; ++i) {\n      first.push(args[i]);\n    }\n  }\n  return first;\n}\nmodule.exports.unpackArgs = unpackArgs;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/searchquery_queries.js":"'use strict';\n\nvar cbutils = require('./utils');\n\n/**\n * @constructor\n * @private\n * @ignore\n */\nfunction QueryBase() {\n  this.data = {};\n}\n\nQueryBase.prototype.field = function(field) {\n  this.data.field = field;\n  return this;\n};\n\nQueryBase.prototype.analyzer = function(analyzer) {\n  this.data.analyzer = analyzer;\n  return this;\n};\n\nQueryBase.prototype.prefixLength = function(prefixLength) {\n  this.data.prefix_length = prefixLength;\n  return this;\n};\n\nQueryBase.prototype.fuzziness = function(fuzziness) {\n  this.data.fuzziness = fuzziness;\n  return this;\n};\n\nQueryBase.prototype.boost = function(boost) {\n  this.data.boost = boost;\n  return this;\n};\n\nQueryBase.prototype.dateTimeParser = function(dateTimeParser) {\n  this.data.datetime_parser = dateTimeParser;\n  return this;\n};\n\nQueryBase.prototype.toJSON = function() {\n  return this.data;\n};\n\nvar SearchQuery = {};\nmodule.exports = SearchQuery;\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction MatchQuery(match) {\n  this.data = {\n    match: match\n  };\n}\nSearchQuery.MatchQuery = MatchQuery;\n\n/**\n * match creates a Query MatchQuery matching text.\n *\n * @param {string} match\n * @returns {SearchQuery.MatchQuery}\n */\nSearchQuery.match = function(match) {\n  return new MatchQuery(match);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.MatchQuery}\n */\nMatchQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * Specifies the analyzer to use for the query.\n *\n * @param {string} analyzer\n * @returns {SearchQuery.MatchQuery}\n */\nMatchQuery.prototype.analyzer = QueryBase.prototype.analyzer;\n\n/**\n * Specifies the prefix length to consider for the query.\n *\n * @param {number} prefixLength\n * @returns {SearchQuery.MatchQuery}\n */\nMatchQuery.prototype.prefixLength = QueryBase.prototype.prefixLength;\n\n/**\n * fuzziness defines the level of fuzziness for the query.\n *\n * @param {number} fuzziness\n * @returns {SearchQuery.MatchQuery}\n */\nMatchQuery.prototype.fuzziness = QueryBase.prototype.fuzziness;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.MatchQuery}\n */\nMatchQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nMatchQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction MatchPhraseQuery(phrase) {\n  this.data = {\n    match_phrase: phrase\n  };\n}\nSearchQuery.MatchPhraseQuery = MatchPhraseQuery;\n\n/**\n * matchPhase creates a new MatchPhraseQuery object for matching\n * phrases in the index.\n *\n * @param {string} phrase\n * @returns {SearchQuery.MatchPhraseQuery}\n */\nSearchQuery.matchPhrase = function(phrase) {\n  return new MatchPhraseQuery(phrase);\n};\n\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.MatchPhraseQuery}\n */\nMatchPhraseQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * Specifies the analyzer to use for the query.\n *\n * @param {string} analyzer\n * @returns {SearchQuery.MatchPhraseQuery}\n */\nMatchPhraseQuery.prototype.analyzer = QueryBase.prototype.analyzer;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.MatchPhraseQuery}\n */\nMatchPhraseQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nMatchPhraseQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction RegexpQuery(regexp) {\n  this.data = {\n    regexp: regexp\n  };\n}\nSearchQuery.RegexpQuery = RegexpQuery;\n\n/**\n * regexp creates a new RegexpQuery object for matching against a\n * regexp query in the index.\n *\n * @param {string} regexp\n * @returns {SearchQuery.RegexpQuery}\n */\nSearchQuery.regexp = function(regexp) {\n  return new RegexpQuery(regexp);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.RegexpQuery}\n */\nRegexpQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.RegexpQuery}\n */\nRegexpQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nRegexpQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction QueryStringQuery(query) {\n  this.data = {\n    query: query\n  };\n}\nSearchQuery.QueryStringQuery = QueryStringQuery;\n\n/**\n * string creates a QueryStringQuery for matching strings.\n *\n * @param {string} query\n * @returns {SearchQuery.QueryStringQuery}\n */\nSearchQuery.queryString = function(query) {\n  return new QueryStringQuery(query);\n};\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.QueryStringQuery}\n */\nQueryStringQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nQueryStringQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction NumericRangeQuery() {\n  this.data = {};\n}\nSearchQuery.NumericRangeQuery = NumericRangeQuery;\n\n/**\n * numericRange creates a NumericRangeQuery for matching numeric\n * ranges in an index.\n *\n * @returns {SearchQuery.NumericRangeQuery}\n */\nSearchQuery.numericRange = function() {\n  return new NumericRangeQuery();\n};\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.NumericRangeQuery}\n */\nNumericRangeQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nNumericRangeQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction DateRangeQuery() {\n  this.data = {};\n}\nSearchQuery.DateRangeQuery = DateRangeQuery;\n\n/**\n * dateRange creates a DateRangeQuery for matching date ranges in an index.\n *\n * @returns {SearchQuery.DateRangeQuery}\n */\nSearchQuery.dateRange = function() {\n  return new DateRangeQuery();\n};\n\n/**\n * dateTimeParser specifies the parser to use against dates in the query.\n *\n * @param {string} dateTimeParser\n * @returns {SearchQuery.DateRangeQuery}\n */\nDateRangeQuery.prototype.dateTimeParser = QueryBase.prototype.dateTimeParser;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.DateRangeQuery}\n */\nDateRangeQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nDateRangeQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction ConjunctionQuery(queries) {\n  queries = cbutils.unpackArgs(queries, arguments);\n  this.data = {\n    conjuncts: []\n  };\n  this.and(queries);\n}\nSearchQuery.ConjunctionQuery = ConjunctionQuery;\n\n/**\n * conjuncts creates a ConjunctionQuery for matching all of a list of\n * subqueries in an index.\n *\n * @param {SearchQuery.Query[]} queries\n * @returns {SearchQuery.ConjunctionQuery}\n */\nSearchQuery.conjuncts = function(queries) {\n  queries = cbutils.unpackArgs(queries, arguments);\n  return new ConjunctionQuery(queries);\n};\n\n/**\n * and specifies additional predicate queries.\n *\n * @param {SearchQuery.Query} queries\n * @returns {SearchQuery.ConjunctionQuery}\n */\nConjunctionQuery.prototype.and = function(queries) {\n  queries = cbutils.unpackArgs(queries, arguments);\n  for (var i = 0; i < queries.length; ++i) {\n    this.data.conjuncts.push(queries[i]);\n  }\n  return this;\n};\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.ConjunctionQuery}\n */\nConjunctionQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nConjunctionQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction DisjunctionQuery(queries) {\n  queries = cbutils.unpackArgs(queries);\n  this.data = {\n    disjuncts: []\n  };\n  this.or(queries);\n}\nSearchQuery.DisjunctionQuery = DisjunctionQuery;\n\n/**\n * disjuncts creates a DisjunctionQuery for matching any of a list of\n * subqueries in an index.\n *\n * @param {SearchQuery.Query[]} queries\n * @returns {SearchQuery.DisjunctionQuery}\n */\nSearchQuery.disjuncts = function(queries) {\n  queries = cbutils.unpackArgs(queries, arguments);\n  return new DisjunctionQuery(queries);\n};\n\n/**\n * or specifies additional predicate queries.\n *\n * @param {SearchQuery.Query} queries\n * @returns {SearchQuery.DisjunctionQuery}\n */\nDisjunctionQuery.prototype.or = function(queries) {\n  queries = cbutils.unpackArgs(queries, arguments);\n  for (var i = 0; i < queries.length; ++i) {\n    this.data.disjuncts.push(queries[i]);\n  }\n  return this;\n};\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.DisjunctionQuery}\n */\nDisjunctionQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {string}\n *\n * @private\n */\nDisjunctionQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction BooleanQuery() {\n  this.data = {};\n  this.shouldMin = undefined;\n}\nSearchQuery.BooleanQuery = BooleanQuery;\n\n/**\n * boolean creates a compound BooleanQuery composed of several\n * other Query objects.\n *\n * @returns {SearchQuery.BooleanQuery}\n */\nSearchQuery.boolean = function() {\n  return new BooleanQuery();\n};\n\n/**\n * must specifies a predicate query which much match.\n *\n * @param {SearchQuery.ConjunctionQuery|SearchQuery.Query} query\n * @returns {SearchQuery.BooleanQuery}\n */\nBooleanQuery.prototype.must = function(query) {\n  if (!(query instanceof ConjunctionQuery)) {\n    query = new ConjunctionQuery([query]);\n  }\n  this.data.must = query;\n  return this;\n};\n\n/**\n * should specifies a predicate query which should match.\n * @param {SearchQuery.DisjunctionQuery|SearchQuery.Query} query\n * @returns {SearchQuery.BooleanQuery}\n */\nBooleanQuery.prototype.should = function(query) {\n  if (!(query instanceof DisjunctionQuery)) {\n    query = new DisjunctionQuery([query]);\n  }\n  this.data.should = query;\n  return this;\n};\n\n/**\n * mustNot specifies a predicate query which must not match.\n *\n * @param {SearchQuery.DisjunctionQuery|SearchQuery.Query} query\n * @returns {SearchQuery.BooleanQuery}\n */\nBooleanQuery.prototype.mustNot = function(query) {\n  if (!(query instanceof DisjunctionQuery)) {\n    query = new DisjunctionQuery([query]);\n  }\n  this.data.must_not = query;\n  return this;\n};\n\n/**\n * shouldMin specifies the minimum score for should predicate matches.\n *\n * @param {number} shouldMin\n * @returns {SearchQuery.BooleanQuery}\n */\nBooleanQuery.prototype.shouldMin = function(shouldMin) {\n  this.shouldMin = shouldMin;\n  return this;\n};\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.BooleanQuery}\n */\nBooleanQuery.prototype.boost = QueryBase.prototype.boost;\n\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nBooleanQuery.prototype.toJSON = function() {\n  var out = {};\n  if (this.data.must) {\n    out.must = this.data.must;\n  }\n  if (this.data.should) {\n    var shouldData = this.data.should.toJSON();\n    shouldData.min = this.shouldMin;\n    out.should = shouldData;\n  }\n  if (this.data.must_not) {\n    out.must_not = this.data.must_not;\n  }\n  return out;\n};\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction WildcardQuery(wildcard) {\n  this.data = {\n    wildcard: wildcard\n  };\n}\nSearchQuery.WildcardQuery = WildcardQuery;\n\n/**\n * wildcard creates a WildcardQuery which allows you to match a\n * string with wildcards in an index.\n *\n * @param {string} wildcard\n * @returns {SearchQuery.WildcardQuery}\n */\nSearchQuery.wildcard = function(wildcard) {\n  return new WildcardQuery(wildcard);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.WildcardQuery}\n */\nWildcardQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.WildcardQuery}\n */\nWildcardQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nWildcardQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction DocIdQuery(ids) {\n  ids = cbutils.unpackArgs(ids, arguments);\n  this.data = {\n    ids: []\n  };\n  this.addDocIds(ids);\n}\nSearchQuery.DocIdQuery = DocIdQuery;\n\n/**\n * docIds creates a DocIdQuery which allows you to match a list of\n * document ids in an index.\n *\n * @param {string[]} ids\n * @returns {SearchQuery.DocIdQuery}\n */\nSearchQuery.docIds = function(ids) {\n  ids = cbutils.unpackArgs(ids, arguments);\n  return new DocIdQuery(ids);\n};\n\nDocIdQuery.prototype.addDocIds = function(ids) {\n  ids = cbutils.unpackArgs(ids, arguments);\n  for (var i = 0; i < ids.length; ++i) {\n    this.data.ids.push(ids);\n  }\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.DocIdQuery}\n */\nDocIdQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.DocIdQuery}\n */\nDocIdQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nDocIdQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction BooleanFieldQuery(val) {\n  this.data = {\n    bool: val\n  };\n}\nSearchQuery.BooleanFieldQuery = BooleanFieldQuery;\n\n/**\n * booleanField creates a BooleanFieldQuery for searching boolean fields\n * in an index.\n *\n * @param {boolean} val\n * @returns {SearchQuery.BooleanFieldQuery}\n */\nSearchQuery.booleanField = function(val) {\n  return new BooleanFieldQuery(val);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.DocIdQuery}\n */\nDocIdQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.DocIdQuery}\n */\nDocIdQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nDocIdQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction TermQuery(term) {\n  this.data = {\n    term: term\n  };\n}\nSearchQuery.TermQuery = TermQuery;\n\n/**\n * term creates a TermQuery for searching terms in an index.\n *\n * @param {string} term\n * @returns {SearchQuery.TermQuery}\n */\nSearchQuery.term = function(term) {\n  return new TermQuery(term);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.TermQuery}\n */\nTermQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * Specifies the prefix length to consider for the query.\n *\n * @param {number} prefixLength\n * @returns {SearchQuery.TermQuery}\n */\nTermQuery.prototype.prefixLength = QueryBase.prototype.prefixLength;\n\n/**\n * fuzziness defines the level of fuzziness for the query.\n *\n * @param {number} fuzziness\n * @returns {SearchQuery.TermQuery}\n */\nTermQuery.prototype.fuzziness = QueryBase.prototype.fuzziness;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.TermQuery}\n */\nTermQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nTermQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction PhraseQuery(terms) {\n  this.data = {\n    terms: terms\n  };\n}\nSearchQuery.PhraseQuery = PhraseQuery;\n\n/**\n * phrase creates a new PhraseQuery for searching a phrase in an index.\n *\n * @param {string[]} terms\n * @returns {SearchQuery.PhraseQuery}\n */\nSearchQuery.phrase = function(terms) {\n  return new PhraseQuery(terms);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.PhraseQuery}\n */\nPhraseQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.PhraseQuery}\n */\nPhraseQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nPhraseQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction PrefixQuery(prefix) {\n  this.data = {\n    prefix: prefix\n  };\n}\nSearchQuery.PrefixQuery = PrefixQuery;\n\n/**\n * prefix creates a new MatchQuery for searching for a prefix in an index.\n *\n * @param {string} prefix\n * @returns {SearchQuery.PrefixQuery}\n */\nSearchQuery.prefix = function(prefix) {\n  return new PrefixQuery(prefix);\n};\n\n/**\n * Specifies the field to query.\n *\n * @param {string} field\n * @returns {SearchQuery.PrefixQuery}\n */\nPrefixQuery.prototype.field = QueryBase.prototype.field;\n\n/**\n * boost defines the amount to boost this query.\n *\n * @param {number} boost\n * @returns {SearchQuery.PrefixQuery}\n */\nPrefixQuery.prototype.boost = QueryBase.prototype.boost;\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nPrefixQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction MatchAllQuery() {\n  this.data = {\n    match_all: null\n  };\n}\nSearchQuery.MatchAllQuery = MatchAllQuery;\n\n/**\n * matchAll creates a MatchAllQuery which matches anything.\n *\n * @returns {SearchQuery.MatchAllQuery}\n */\nSearchQuery.matchAll = function() {\n  return new MatchAllQuery();\n};\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nMatchAllQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n\n\n/**\n * @constructor\n *\n * @private\n * @memberof SearchQuery\n */\nfunction MatchNoneQuery() {\n  this.data = {\n    match_none: null\n  };\n}\nSearchQuery.MatchNoneQuery = MatchNoneQuery;\n\n/**\n * matchNone creates a MatchNoneQuery which matches nothing.\n *\n * @returns {SearchQuery.MatchNoneQuery}\n */\nSearchQuery.matchNone = function() {\n  return new MatchNoneQuery();\n};\n\n/**\n * Serializes this query to JSON for network dispatch.\n *\n * @returns {Object}\n *\n * @private\n */\nMatchNoneQuery.prototype.toJSON = QueryBase.prototype.toJSON;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/bucketmgr.js":"'use strict';\n\nvar N1qlQuery = require('./n1qlquery');\n\nfunction _respRead(callback) {\n  return function(resp) {\n    resp.setEncoding('utf8');\n    var strBuffer = '';\n    resp.on('data', function (data) {\n      strBuffer += data;\n    });\n    resp.on('end', function () {\n      callback(null, resp, strBuffer);\n    });\n    resp.on('error', function (err) {\n      callback(err, resp, null);\n    });\n  };\n}\n\n/**\n * @class\n * A class for performing management operations against a bucket. This class\n * should not be instantiated directly, but instead through the use of the\n * {@link Bucket#manager} method instead.\n *\n * @param bucket\n *\n * @private\n *\n * @since 2.0.0\n * @committed\n */\nfunction BucketManager(bucket) {\n  this._bucket = bucket;\n}\n\n/**\n * Method for performing a http mgmt operation using the underlying bucket.\n *\n * @param path\n * @param method\n * @param callback\n *\n * @private\n * @ignore\n */\nBucketManager.prototype._mgmtRequest = function(path, method, callback) {\n  var b = this._bucket;\n  b._maybeInvoke(b._mgmtRequest.bind(b), [path, method, callback]);\n};\n\n/**\n * Method for performing a http capi request using the underlying bucket.\n *\n * @param path\n * @param method\n * @param callback\n *\n * @private\n * @ignore\n */\nBucketManager.prototype._capiRequest = function(path, method, callback) {\n  var b = this._bucket;\n  b._maybeInvoke(b._capiRequest.bind(b), [path, method, callback]);\n};\n\n/**\n * Retrieves a list of all design documents registered to a bucket.\n *\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nBucketManager.prototype.getDesignDocuments = function(callback) {\n  var path = 'pools/default/buckets/' + this._bucket._name + '/ddocs';\n\n  this._mgmtRequest(path, 'GET', function(err, httpReq) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    httpReq.on('response', _respRead(function (err, resp, data) {\n      if (err) {\n        return callback(err);\n      }\n      if (resp.statusCode !== 200) {\n        var errData = null;\n        try {\n          errData = JSON.parse(data);\n        } catch(e) {\n        }\n\n        if (!errData) {\n          callback(new Error(\n              'operation failed (' + resp.statusCode +')'), null);\n          return;\n        }\n\n        callback(new Error(errData.reason), null);\n        return;\n      }\n      var ddocData = JSON.parse(data);\n      var ddocs = {};\n      for (var i = 0; i < ddocData.rows.length; ++i) {\n        var ddoc = ddocData.rows[i].doc;\n        var ddocName = ddoc.meta.id.substr(8);\n        ddocs[ddocName] = ddoc.json;\n      }\n      callback(null, ddocs);\n    }));\n    httpReq.end();\n  });\n};\n\n/**\n * Registers a design document to this bucket, failing if it already exists.\n *\n * @param name\n * @param data\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nBucketManager.prototype.insertDesignDocument = function(name, data, callback) {\n  var self = this;\n  this.getDesignDocument(name, function(err, res) {\n    if (!err) {\n      return callback(new Error('design document already exists'), null);\n    }\n    self.upsertDesignDocument(name, data, callback);\n  });\n};\n\n/**\n * Registers a design document to this bucket, overwriting any existing\n * design document that was previously registered.\n *\n * @param name\n * @param data\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nBucketManager.prototype.upsertDesignDocument = function(name, data, callback) {\n  var path = '_design/' + name;\n\n  this._capiRequest(path, 'PUT', function(err, httpReq) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    httpReq.on('response', _respRead(function(err, resp, data) {\n      if (err) {\n        return callback(err);\n      }\n      if (resp.statusCode !== 201) {\n        var errData = null;\n        try {\n          errData = JSON.parse(data);\n        } catch(e) {\n        }\n\n        if (!errData) {\n          callback(new Error(\n              'operation failed (' + resp.statusCode +')'), null);\n          return;\n        }\n\n        callback(new Error(errData.reason), null);\n        return;\n      }\n      callback(null, true);\n    }));\n    httpReq.write(JSON.stringify(data, function(key, value) {\n      if (value instanceof Function) {\n        return value.toString();\n      }\n      return value;\n    }));\n    httpReq.end();\n  });\n};\n\n/**\n * Retrieves a specific design document from this bucket.\n *\n * @param name\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nBucketManager.prototype.getDesignDocument = function(name, callback) {\n  var path = '_design/' + name;\n\n  this._capiRequest(path, 'GET', function(err, httpReq) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    httpReq.on('response', _respRead(function(err, resp, data) {\n      if (err) {\n        return callback(err);\n      }\n      var ddocData = JSON.parse(data);\n      if (resp.statusCode !== 200) {\n        var errData = null;\n        try {\n          errData = JSON.parse(data);\n        } catch(e) {\n        }\n\n        if (!errData) {\n          callback(new Error(\n              'operation failed (' + resp.statusCode +')'), null);\n          return;\n        }\n\n        callback(new Error(errData.reason), null);\n        return;\n      }\n      callback(null, ddocData);\n    }));\n    httpReq.end();\n  });\n};\n\n/**\n * Unregisters a design document from this bucket.\n *\n * @param name\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nBucketManager.prototype.removeDesignDocument = function(name, callback) {\n  var path = '_design/' + name;\n\n  this._capiRequest(path, 'DELETE', function(err, httpReq) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    httpReq.on('response', _respRead(function(err, resp, data) {\n      if (err) {\n        return callback(err);\n      }\n      if (resp.statusCode !== 200) {\n        var errData = null;\n        try {\n          errData = JSON.parse(data);\n        } catch(e) {\n        }\n\n        if (!errData) {\n          callback(new Error(\n              'operation failed (' + resp.statusCode +')'), null);\n          return;\n        }\n\n        callback(new Error(errData.reason), null);\n        return;\n      }\n      callback(null, true);\n    }));\n    httpReq.end();\n  });\n};\n\n/**\n * Flushes the cluster, deleting all data stored within this bucket.  Note that\n * this method requires the Flush permission to be enabled on the bucket from\n * the management console before it will work.\n *\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nBucketManager.prototype.flush = function(callback) {\n  var path = 'pools/default/buckets/' +\n      this._bucket._name + '/controller/doFlush';\n\n  this._mgmtRequest(path, 'POST', function(err, httpReq) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    httpReq.on('response', _respRead(function(err, resp, data) {\n      if (err) {\n        return callback(err);\n      }\n      if (resp.statusCode !== 200) {\n        var errData = null;\n        try {\n          errData = JSON.parse(data);\n        } catch(e) {\n        }\n\n        if (!errData) {\n          callback(new Error(\n              'operation failed (' + resp.statusCode +')'), null);\n          return;\n        }\n\n        callback(new Error(errData.reason), null);\n        return;\n      }\n      callback(null, true);\n    }));\n    httpReq.end();\n  });\n};\n\n/**\n * Method for creating GSI indexes\n *\n * @param options\n * @param options.name\n * @param options.fields\n * @param options.deferred\n * @param callback\n *\n * @private\n * @ignore\n */\nBucketManager.prototype._createIndex = function(options, callback) {\n  if (!options.fields) {\n    options.fields = [];\n  }\n\n  var qs = '';\n\n  if (options.fields.length === 0) {\n    qs += 'CREATE PRIMARY INDEX';\n  } else {\n    qs += 'CREATE INDEX';\n  }\n  if (options.name !== '') {\n    qs += ' `' + options.name + '`';\n  }\n  qs += ' ON `' + this._bucket._name + '`';\n  if (options.fields.length > 0) {\n    qs += '(';\n    for (var i = 0; i < options.fields.length; ++i) {\n      if (i > 0) {\n        qs += ', ';\n      }\n      qs += '`' + options.fields[i] + '`';\n    }\n    qs += ')';\n  }\n  if (options.deferred) {\n    qs += ' WITH {\"defer_build\": true}';\n  }\n\n  this._bucket.query(N1qlQuery.fromString(qs), function(err, rows) {\n    if (err) {\n      if (err.message.indexOf('already exist') !== -1 &&\n          options.ignoreIfExists) {\n        callback(null);\n        return;\n      }\n\n      callback(err);\n      return;\n    }\n\n    callback(null);\n  });\n};\n\n/**\n * Creates a non-primary GSI index from a name and list of fields.\n *\n * @param indexName\n * @param fields\n * @param options\n * @param options.ignoreIfExists\n * @param options.deferred\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.createIndex =\n    function(indexName, fields, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = undefined;\n  }\n  if (!options) {\n    options = {};\n  }\n\n  return this._createIndex({\n    name: indexName,\n    fields: fields,\n    ignoreIfExists: options.ignoreIfExists,\n    deferred: options.deferred\n  }, callback);\n};\n\n/**\n * Creates a primary GSI index with an optional name\n * @param options\n * @param options.ignoreIfExists\n * @param options.deferred\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.createPrimaryIndex = function(options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[0];\n    options = undefined;\n  }\n  if (!options) {\n    options = {};\n  }\n\n  return this._createIndex({\n    name: options.name,\n    ignoreIfExists: options.ignoreIfExists,\n    deferred: options.deferred\n  }, callback);\n};\n\n/**\n * Method for dropping GSI indexes\n *\n * @param options\n * @param options.name\n * @param callback\n *\n * @private\n * @ignore\n */\nBucketManager.prototype._dropIndex = function(options, callback) {\n  var qs = '';\n\n  if (!options.name) {\n    qs += 'DROP PRIMARY INDEX `' + this._bucket._name + '`';\n  } else {\n    qs += 'DROP INDEX `' + this._bucket._name + '`.`' + options.name + '`';\n  }\n\n  this._bucket.query(N1qlQuery.fromString(qs), function(err) {\n    if (err) {\n      if (err.message.indexOf('not found') !== -1 &&\n          options.ignoreIfNotExists) {\n        callback(null);\n        return;\n      }\n\n      callback(err);\n      return;\n    }\n\n    callback(null);\n  });\n};\n\n/**\n * Drops a specific GSI index by name.\n *\n * @param indexName\n * @param options\n * @param options.ignoreIfNotExists\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.dropIndex = function(indexName, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = undefined;\n  }\n  if (!options) {\n    options = {};\n  }\n\n  return this._dropIndex({\n    name: indexName,\n    ignoreIfNotExists: options.ignoreIfNotExists\n  }, callback);\n};\n\n/**\n * Drops a primary GSI index\n *\n * @param options\n * @param options.ignoreIfNotExists\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.dropPrimaryIndex = function(options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = undefined;\n  }\n  if (!options) {\n    options = {};\n  }\n\n  return this._dropIndex({\n    name: options.name,\n    ignoreIfNotExists: options.ignoreIfNotExists\n  }, callback);\n};\n\n/**\n * Retreives a list of the indexes currently configured on the cluster.\n *\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.getIndexes = function(callback) {\n  var qs = 'SELECT `indexes`.* FROM system:indexes';\n  this._bucket.query(N1qlQuery.fromString(qs), function(err, rows) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    callback(null, rows);\n  });\n};\n\n/**\n * Builds any indexes that were previously created with the deferred attribute.\n *\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.buildDeferredIndexes = function(callback) {\n  this.getIndexes(function(err, indexes) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    var deferredList = [];\n    for (var i = 0; i < indexes.length; ++i) {\n      if (indexes[i].state === 'deferred' || indexes[i].state === 'pending') {\n        deferredList.push(indexes[i].name);\n      }\n    }\n\n    if (deferredList.length === 0) {\n      callback(null, deferredList);\n      return;\n    }\n\n    var qs = '';\n    qs += 'BUILD INDEX ON `' + this._bucket._name + '`(';\n    for (var j = 0; j < deferredList.length; ++i) {\n      if (j > 0) {\n        qs += ', ';\n      }\n      qs += '`' + deferredList[j] + '`';\n    }\n\n    this._bucket.query(N1qlQuery.fromString(qs), function(err) {\n      if (err) {\n        callback(err, deferredList);\n        return;\n      }\n\n      callback(null, deferredList);\n    });\n  });\n};\n\n/**\n * Method for checking a list of indexes to see if they are active\n *\n * @param checkList\n * @param callback\n *\n * @private\n * @ignore\n */\nBucketManager.prototype._checkIndexesActive = function(checkList, callback) {\n  this.getIndexes(function(err, indexes) {\n    if (err) {\n      callback(err, false);\n      return;\n    }\n\n    var checkIndexes = [];\n    for (var i = 0; i < indexes.length; i++) {\n      if (checkList.indexOf(indexes[i].name) !== -1) {\n        checkIndexes.push(indexes[i]);\n      }\n    }\n\n    if (checkIndexes.length !== checkList.length) {\n      callback(new Error('index not found'), false);\n      return;\n    }\n\n    for (var j = 0; j < checkIndexes.length; ++j) {\n      if (checkIndexes[j].state !== 'online') {\n        callback(null, false);\n        return;\n      }\n    }\n\n    callback(null, true);\n  });\n};\n\n/**\n * Watches a list of indexes; waiting for them to become available for use.\n *\n * @param watchList\n * @param options \n * @param options.timeout Timeout in millseconds\n * @param callback\n *\n * @since 2.1.6\n * @committed\n */\nBucketManager.prototype.watchIndexes = function(watchList, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = undefined;\n  }\n  if (!options) {\n    options = {};\n  }\n\n  var timeoutTime = 0;\n  if (options.timeout) {\n    timeoutTime = Date.now() + options.timeout;\n  }\n\n  var self = this;\n  var curInterval = 50;\n  (function _checkIndexes() {\n    self._checkIndexesActive(watchList, function(err, allActive) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (allActive) {\n        callback(null);\n        return;\n      }\n\n      if (timeoutTime > 0 && Date.now() + curInterval > timeoutTime) {\n        callback(new Error('timeout'));\n        return;\n      }\n\n      setTimeout(function() {\n        curInterval += 500;\n        if (curInterval > 1000) {\n          curInterval = 1000;\n        }\n\n        _checkIndexes();\n      }, curInterval);\n    });\n  })();\n};\n\nmodule.exports = BucketManager;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/clustermgr.js":"'use strict';\n\nvar http = require('http');\nvar qs = require('querystring');\n\nfunction _respRead(callback) {\n  return function(resp) {\n    resp.setEncoding('utf8');\n    var strBuffer = '';\n    resp.on('data', function (data) {\n      strBuffer += data;\n    });\n    resp.on('end', function () {\n      callback(null, resp, strBuffer);\n    });\n    resp.on('error', function (err) {\n      callback(err, resp, null);\n    });\n  };\n}\n\nfunction _respParseError(resp, data) {\n  if (resp.statusCode < 200 || resp.statusCode >= 300) {\n    var errData = null;\n    try {\n      errData = JSON.parse(data);\n    } catch(e) {\n    }\n\n    if (!errData) {\n      return new Error(\n          'operation failed (' + resp.statusCode +')');\n    }\n\n    var errMessage = null;\n    if (errData._) {\n      // return errData._\n      errMessage = errData._;\n    } else if (errData.errors) {\n      // join values (messages) of all properties in errData.errors object\n      errMessage = Object.keys(errData.errors).map(function(errKey) {\n        return errData.errors[errKey];\n      }).join(' ');\n    } else if (errData !== null && typeof errData === 'object') {\n      // join values (messages) of all properties in errData object\n      errMessage = Object.keys(errData).map(function(errKey) {\n        return errData[errKey];\n      }).join(' ');\n    }\n    var errObj = new Error(errMessage);\n    // add full response and status code to the error\n    errObj.response = errData;\n    errObj.statusCode = resp.statusCode;\n    return errObj;\n  }\n\n  return null;\n}\n\n/**\n * @class\n * Class for performing management operations against a cluster.\n *\n * @param cluster\n * @param username\n * @param password\n *\n * @private\n *\n * @since 2.0.0\n * @committed\n */\nfunction ClusterManager(cluster, username, password) {\n  this._cluster = cluster;\n  this._username = username;\n  this._password = password;\n}\n\n/**\n * @param path\n * @param method\n * @param uses_qs\n * @returns {http.ClientRequest}\n *\n * @private\n * @ignore\n */\nClusterManager.prototype._mgmtRequest = function(path, method, uses_qs) {\n  var clusterHosts = this._cluster.dsnObj.hosts;\n  var myHost = clusterHosts[Math.floor(Math.random()*clusterHosts.length)];\n  var reqOpts = {\n    hostname: myHost[0],\n    port: myHost[1] ? myHost[1] : 8091,\n    path: '/' + path,\n    method: method,\n    headers: {\n      'Content-Type': (uses_qs ? 'application/x-www-form-urlencoded' :\n        'application/json' )\n    }\n  };\n  if (this._password) {\n    reqOpts.auth = this._username + ':' + this._password;\n  }\n  return http.request(reqOpts);\n};\n\n/**\n * Retrieves a list of buckets present on this cluster.\n *\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nClusterManager.prototype.listBuckets = function(callback) {\n  var path = 'pools/default/buckets';\n\n  var httpReq = this._mgmtRequest(path, 'GET');\n  httpReq.on('response', _respRead(function(err, resp, data) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    err = _respParseError(resp, data);\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var bucketInfo;\n    try {\n      bucketInfo = JSON.parse(data);\n    } catch (e) {\n      err = e;\n    }\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, bucketInfo);\n  }));\n  httpReq.end();\n};\n\n/**\n * Creates a new bucket on this cluster.  Note that the callback is invoked\n * after the bucket is created, but it may not be immediately accessible due\n * to server spin-up time.\n *\n * @param name\n * @param opts\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nClusterManager.prototype.createBucket = function(name, opts, callback) {\n  var myOpts = {\n    name: name,\n    authType: 'sasl',\n    bucketType: 'couchbase',\n    ramQuotaMB: 100,\n    replicaNumber: 1\n  };\n  for (var i in opts) {\n    if (opts.hasOwnProperty(i)) {\n      myOpts[i] = opts[i];\n    }\n  }\n\n  var path = 'pools/default/buckets';\n\n  var httpReq = this._mgmtRequest(path, 'POST', true);\n  httpReq.on('response', _respRead(function (err, resp, data) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    err = _respParseError(resp, data);\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, true);\n  }));\n  httpReq.write(qs.stringify(myOpts));\n  httpReq.end();\n};\n\n/**\n * Removes a bucket from the cluster.\n *\n * @param name\n * @param callback\n *\n * @since 2.0.0\n * @committed\n */\nClusterManager.prototype.removeBucket = function(name, callback) {\n  var path = 'pools/default/buckets/' + name;\n\n  var httpReq = this._mgmtRequest(path, 'DELETE');\n  httpReq.on('response', _respRead(function(err, resp, data) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    err = _respParseError(resp, data);\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, true);\n  }));\n  httpReq.end();\n};\n\n/**\n * Upserts a new RBAC built-in user to the cluster.\n *\n * @param settings\n * @param callback\n *\n * @since 2.3.2\n * @committed\n */\nClusterManager.prototype.upsertUser = function(userid, settings, callback) {\n  var httpReq =\n      this._mgmtRequest('/settings/rbac/users/builtin/' + userid, 'PUT');\n  httpReq.on('response', _respRead(function(err, resp, data) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    err = _respParseError(resp, data);\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, true);\n  }));\n  var qsroles = [];\n  for (var i = 0; i < settings.roles.length; ++i) {\n    var role = settings.roles[i];\n    qsroles.push(role.role + '[' + role.bucket_name + ']');\n  }\n  var qssettings = {\n    name: settings.name,\n    password: settings.password,\n    roles: qsroles.join(',')\n  };\n  httpReq.setHeader('Content-Type', 'application/x-www-form-urlencoded');\n  httpReq.write(qs.stringify(qssettings));\n  httpReq.end();\n};\n\n/**\n * Removes an RBAC built-in user from the cluster.\n * @param callback\n *\n * @since 2.3.2\n * @committed\n */\nClusterManager.prototype.removeUser = function(userid, callback) {\n  var httpReq =\n      this._mgmtRequest('/settings/rbac/users/builtin/' + userid, 'DELETE');\n  httpReq.on('response', _respRead(function(err, resp, data) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    err = _respParseError(resp, data);\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, true);\n  }));\n  httpReq.end();\n};\n\n/**\n * Retrieves a list of RBAC built-in users on this cluster.\n *\n * @param callback\n *\n * @since 2.3.2\n * @committed\n */\nClusterManager.prototype.getUsers = function(callback) {\n  var httpReq = this._mgmtRequest('/settings/rbac/users', 'GET');\n  httpReq.on('response', _respRead(function(err, resp, data) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    err = _respParseError(resp, data);\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var users;\n    try {\n      users = JSON.parse(data);\n    } catch (e) {\n      err = e;\n    }\n\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    callback(null, users);\n  }));\n  httpReq.end();\n};\n\nmodule.exports = ClusterManager;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/cbasquery.js":"'use strict';\n\nvar util = require('util');\nvar qs = require('querystring');\n\n/**\n * Class for dynamically construction of CBAS queries.  This class should never\n * be constructed directly, instead you should use the\n * {@link CbasQuery.fromString} static method to instantiate a\n * {@link CbasStringQuery}.\n *\n * @constructor\n *\n * @since 2.2.4\n * @uncommitted\n */\nfunction CbasQuery() {\n}\n\n/**\n * Returns the fully prepared string representation of this query.\n *\n * @since 2.2.4\n * @uncommitted\n */\nCbasQuery.prototype.toString = function() {\n  throw new Error('Must use CbasQuery subclasses only.');\n};\n\nmodule.exports = CbasQuery;\n\n/**\n * Class for holding a explicitly defined CBAS query string.\n *\n * @constructor\n * @extends CbasQuery\n *\n * @since 2.2.4\n * @uncommitted\n */\nfunction CbasStringQuery(str) {\n  this.options = {\n    statement: str\n  };\n}\nutil.inherits(CbasStringQuery, CbasQuery);\nCbasQuery.Direct = CbasStringQuery;\n\n/**\n * Returns the fully prepared string representation of this query.\n *\n * @since 2.2.4\n * @uncommitted\n */\nCbasStringQuery.prototype.toString = function(args) {\n  return qs.stringify(this.toObject(args));\n};\n\n\n/**\n * Returns the fully prepared object representation of this query.\n *\n * @since 2.2.4\n * @uncommitted\n */\nCbasStringQuery.prototype.toObject = function(args) {\n  if (args) {\n    throw new Error('CBAS queries do not yet support parameterization');\n  }\n\n  return this.options;\n};\n\n\n/**\n * Creates a query object directly from the passed query string.\n *\n * @param {string} str The N1QL query string.\n * @returns {CbasStringQuery}\n *\n * @since 2.2.4\n * @uncommitted\n */\nCbasQuery.fromString = function(str) {\n  return new CbasStringQuery(str);\n};\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/searchquery_facets.js":"'use strict';\n\n/**\n * Represents a Couchbase FTS term facet.\n *\n * @constructor\n *\n * @private\n * @memberof SearchFacet\n */\nfunction TermFacet(field, size) {\n  this.field = field;\n  this.size = size;\n}\nmodule.exports.TermFacet = TermFacet;\n\n/**\n * term creates a Couchbase FTS term facet.\n *\n * @param {string} field\n * @param {number} size\n * @returns {TermFacet}\n */\nmodule.exports.term = function(field, size) {\n  return new TermFacet(field, size);\n};\n\n/**\n * Represents a Couchbase Search numeric facet.\n *\n * @constructor\n *\n * @private\n * @memberof SearchFacet\n */\nfunction NumericFacet(field, size) {\n  this.field = field;\n  this.size = size;\n  this.numeric_ranges = [];\n}\nmodule.exports.NumericFacet = NumericFacet;\n\n/**\n * numeric creates a Couchbase Search numeric facet.\n *\n * @param {string} field\n * @param {number} size\n * @returns {NumericFacet}\n */\nmodule.exports.numeric = function(field, size) {\n  return new NumericFacet(field, size);\n};\n\n/**\n * Adds a numeric range to this numeric facet.\n *\n * @param {string} name\n * @param {number} start\n * @param {number} end\n * @returns {NumericFacet}\n */\nNumericFacet.prototype.addRange = function(name, start, end) {\n  this.numeric_ranges.push({\n    name: name,\n    start: start,\n    end: end\n  });\n  return this;\n};\n\n/**\n * Represents a Couchbase Search date facet.\n *\n * @constructor\n *\n * @private\n * @memberof SearchFacet\n */\nfunction DateFacet(field, size) {\n  this.field = field;\n  this.size = size;\n  this.date_ranges = [];\n}\nmodule.exports.DateFacet = DateFacet;\n\n/**\n * date creates a Couchbase Search date facet.\n *\n * @param {string} field\n * @param {number} size\n * @returns {DateFacet}\n */\nmodule.exports.date = function(field, size) {\n  return new DateFacet(field, size);\n};\n\n/**\n * Adds a date range to this numeric facet.\n *\n * @param {string} name\n * @param {string} start\n * @param {string} end\n * @returns {DateFacet}\n */\nDateFacet.prototype.addRange = function(name, start, end) {\n  this.date_ranges.push({\n    name: name,\n    start: start,\n    end: end\n  });\n  return this;\n};\n\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mutationstate.js":"'use strict';\n\n/**\n * Implements mutation token aggregation for performing consistentWith\n * N1qlQuery's.  Accepts any number of arguments (one per document/tokens).\n *\n * @constructor\n * \n * @since 2.1.7\n * @uncommitted\n */\nfunction MutationState() {\n  this._data = {};\n  for (var i = 0; i < arguments.length; ++i) {\n    this._addSingle(arguments[i]);\n  }\n}\n\nMutationState.prototype._addSingle = function(token) {\n  if (!token) {\n    return;\n  }\n  if (token.token) {\n    token = token.token;\n  }\n  var tokenData = token.toString().split(':');\n  if (tokenData.length < 4 || tokenData[3] === '') {\n    return;\n  }\n  var vbId = tokenData[0];\n  var vbUuid = tokenData[1];\n  var vbSeqNo = parseInt(tokenData[2], 10);\n  var bucketName = tokenData[3];\n\n  if (!this._data[bucketName]) {\n    this._data[bucketName] = {};\n  }\n  if (!this._data[bucketName][vbId]) {\n    this._data[bucketName][vbId] = [vbSeqNo, vbUuid];\n  } else {\n    var info = this._data[bucketName][vbId];\n    if (info[0] < vbSeqNo) {\n      info[0] = vbSeqNo;\n    }\n  }\n};\n\n/**\n * Adds an additional token to this MutationState\n * Accepts any number of arguments (one per document/tokens).\n *\n * @since 2.1.7\n * @uncommitted\n */\nMutationState.prototype.add = function() {\n  for (var i = 0; i < arguments.length; ++i) {\n    this._addSingle(arguments[i]);\n  }\n};\n\nMutationState.prototype.toJSON = function() {\n  return this._data;\n};\n\nMutationState.prototype.inspect = function() {\n  var tokens = '';\n  for (var bucket in this._data) {\n    if (this._data.hasOwnProperty(bucket)) {\n      for (var vbid in this._data[bucket]) {\n        if (this._data[bucket].hasOwnProperty(vbid)) {\n          var info = this._data[bucket][vbid];\n          if (tokens !== '') {\n            tokens += ';';\n          }\n          tokens += vbid + ':' + info[0] + ':' +\n              info[1] + ':' + bucket;\n        }\n      }\n    }\n  }\n  return 'MutationState<' + tokens + '>';\n};\n\nmodule.exports = MutationState;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mock/couchbase.js":"'use strict';\n\nmodule.exports.Cluster = require('./cluster');\nmodule.exports.SpatialQuery = require('../spatialquery');\nmodule.exports.ViewQuery = require('../viewquery');\nmodule.exports.N1qlQuery = require('../n1qlquery');\nmodule.exports.Mock = module.exports;\nmodule.exports.Error = require('./error');\nmodule.exports.errors = require('../errors');\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mock/cluster.js":"'use strict';\n\nvar connstr = require('../connstr');\nvar MockBucket = require('./bucket');\nvar MockClusterManager = require('./clustermgr');\n\nfunction MockCluster(cnstr) {\n  this.dsnObj = connstr.parse(cnstr);\n}\n\nMockCluster.prototype.openBucket = function(name, password, callback) {\n  if (password instanceof Function) {\n    callback = arguments[1];\n    password = arguments[9];\n  }\n\n  var bucketDsnObj = connstr.normalize(this.dsnObj);\n  bucketDsnObj.bucket = name;\n\n  var bucket = new MockBucket({\n    dsnObj: bucketDsnObj,\n    username: name,\n    password: password\n  });\n  if (callback) {\n    bucket.on('connect', callback);\n    bucket.on('error', callback);\n  }\n  return bucket;\n};\n\nMockCluster.prototype.manager = function(username, password) {\n  return new MockClusterManager(this, username, password);\n};\n\nmodule.exports = MockCluster;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mock/bucket.js":"'use strict';\n\nvar events = require('events');\nvar util = require('util');\nvar ViewQuery = require('../viewquery');\nvar SpatialQuery = require('../spatialquery');\nvar N1qlQuery = require('../n1qlquery');\nvar BucketManager = require('./bucketmgr');\nvar CbError = require('./error');\nvar errs = require('../errors');\n\n// Mock version should match the latest fully supported version of couchnode.\nvar MOCK_VERSION = '2.0.0';\n\nfunction MockCouchbaseCas(idx) {\n  this.x = idx;\n}\nMockCouchbaseCas.prototype.toString = function() {\n  return this.x.toString(10);\n};\nMockCouchbaseCas.prototype.toJSON = function() {\n  return this.x.toString(10);\n};\nMockCouchbaseCas.prototype.inspect = function() {\n  return 'MockCouchbaseCas<' + this.x + '>';\n};\n\nvar casCounter = 0;\n/* istanbul ignore next */\nfunction _createCas() {\n  return new MockCouchbaseCas(casCounter++);\n}\n/* istanbul ignore next */\nfunction _compareCas(a, b) {\n  if (!b) {\n    return true;\n  } else if (!a && b) {\n    return false;\n  } else {\n    if (typeof a === 'string') {\n      a = {x: parseInt(a, 10)};\n    }\n    if (typeof b === 'string') {\n      b = {x: parseInt(b, 10)};\n    }\n    return a.x === b.x;\n  }\n}\n/* istanbul ignore next */\nfunction _makeExpiryDate(expiry) {\n  if (!expiry) {\n    return null;\n  }\n\n  if (expiry <= 30*24*60*60) {\n    var dt = new Date();\n    dt.setTime(dt.getTime() + (expiry*1000));\n    return dt;\n  } else {\n    return new Date(expiry * 1000);\n  }\n}\n/* istanbul ignore next */\nfunction _makeLockDate(lockTime) {\n  var dt = new Date();\n  dt.setTime(dt.getTime() + (lockTime*1000));\n  return dt;\n}\n\nvar FLAGS = {\n  // Node Flags - Formats\n  NF_JSON: 0x00,\n  NF_RAW: 0x02,\n  NF_UTF8: 0x04,\n  NF_MASK: 0xFF\n};\nfunction _defaultEncode(doc) {\n  if (typeof doc === 'string') {\n    return {\n      flags: FLAGS.NF_UTF8,\n      value: new Buffer(doc, 'utf8')\n    };\n  } else if (Buffer.isBuffer(doc)) {\n    return {\n      flags: FLAGS.NF_RAW,\n      value: new Buffer(doc)\n    };\n  } else {\n    return {\n      flags: FLAGS.NF_JSON,\n      value: new Buffer(JSON.stringify(doc), 'utf8')\n    };\n  }\n}\nfunction _defaultDecode(info) {\n  if (info.flags === FLAGS.NF_UTF8) {\n    return info.value.toString('utf8');\n  } else if (info.flags === FLAGS.NF_RAW) {\n    return new Buffer(info.value);\n  } else if (info.flags === FLAGS.NF_JSON) {\n    return JSON.parse(info.value.toString('utf8'));\n  } else {\n    return new Buffer(info.value);\n  }\n}\n\n/* istanbul ignore next */\nfunction MockStorage() {\n  this.items = {};\n}\n/* istanbul ignore next */\nMockStorage.prototype._encodeKey = function(key) {\n  return key;\n};\n/* istanbul ignore next */\nMockStorage.prototype.get = function(key, hashkey) {\n  if (!hashkey) {\n    throw new Error('invalid hashkey');\n  }\n\n  var keyItem = this.items[this._encodeKey(key)];\n  if (!keyItem) {\n    return null;\n  }\n  var item = keyItem[this._encodeKey(hashkey)];\n  if (!item) {\n    return null;\n  }\n  if (item.expiry && item.expiry <= new Date()) {\n    return null;\n  }\n  return item;\n};\n/* istanbul ignore next */\nMockStorage.prototype.set = function(key, hashkey, item) {\n  if (!hashkey) {\n    throw new Error('invalid hashkey');\n  }\n\n  var keyE = this._encodeKey(key);\n  var hashkeyE = this._encodeKey(hashkey);\n  if (!this.items[keyE]) {\n    this.items[keyE] = {};\n  }\n  this.items[keyE][hashkeyE] = item;\n};\n/* istanbul ignore next */\nMockStorage.prototype.remove = function(key, hashkey) {\n  if (!hashkey) {\n    throw new Error('invalid hashkey');\n  }\n\n  var keyE = this._encodeKey(key);\n  var hashkeyE = this._encodeKey(hashkey);\n  if (!this.items[keyE]) {\n    return null;\n  }\n\n  delete this.items[keyE][hashkeyE];\n  return _createCas();\n};\n\nfunction MockBucket(options) {\n  this.storage = new MockStorage();\n  this.ddocs = {};\n  this.operationTimeout = 2500;\n  this.viewTimeout = 2500;\n  this.durabilityTimeout = 2500;\n  this.durabilityInterval = 2500;\n  this.managementTimeout = 2500;\n  this.configThrottle = 2500;\n  this.connectionTimeout = 2500;\n  this.nodeConnectionTimeout = 2500;\n  this._encodeDoc = _defaultEncode;\n  this._decodeDoc = _defaultDecode;\n\n  var self = this;\n\n  var connOpts = options.dsnObj;\n\n  this.connected = null;\n  process.nextTick(function() {\n    if (connOpts.bucket !== 'invalid_bucket') {\n      self.connected = true;\n      self.emit('connect');\n    } else {\n      self.connected = false;\n      self.emit('error', new Error('invalid bucket name'));\n    }\n  });\n\n  this.waitQueue = [];\n  this.on('connect', function() {\n    for (var i = 0; i < this.waitQueue.length; ++i) {\n      this.waitQueue[i][0].call(this);\n    }\n    this.waitQueue = [];\n  });\n  this.on('error', function(err) {\n    for (var i = 0; i < this.waitQueue.length; ++i) {\n      this.waitQueue[i][1].call(this, err,  null);\n    }\n    this.waitQueue = [];\n  });\n}\nutil.inherits(MockBucket, events.EventEmitter);\n\nMockBucket.prototype.dump = function() {\n  var out = {\n    data: {},\n    ddocs: this.ddocs\n  };\n\n  var keyspace = this.storage.items;\n  for (var i in keyspace) {\n    if (keyspace.hasOwnProperty(i)) {\n      var hashspace = keyspace[i];\n      if (hashspace[i]) {\n        var data = hashspace[i];\n        out.data[i] = {\n          value: this._decodeDoc({value:data.value,flags:data.flags}),\n          flags: data.flags,\n          expiry: data.expiry,\n          cas: data.cas\n        };\n      }\n    }\n  }\n\n  console.log(util.inspect(out, {depth: 16}));\n};\n\n/* istanbul ignore next */\nMockBucket.prototype.enableN1ql = function(uri) {\n  throw new Error('not supported on mock');\n};\n\nMockBucket.prototype.manager = function() {\n  return new BucketManager(this);\n};\n\nMockBucket.prototype.disconnect = function() {\n  this.connected = false;\n};\n\nMockBucket.prototype.setTranscoder = function(encoder, decoder) {\n  if (encoder) {\n    this._encodeDoc = encoder;\n  } else {\n    this._encodeDoc = _defaultEncode;\n  }\n  if (decoder) {\n    this._decodeDoc = decoder;\n  } else {\n    this._decodeDoc = _defaultDecode;\n  }\n};\n\nMockBucket.prototype._maybeInvoke = function(fn, callback) {\n  if (this.connected === true) {\n    setImmediate(fn.bind(this));\n  } else if (this.connected === false) {\n    throw new Error('cannot perform operations on a shutdown bucket');\n  } else {\n    this.waitQueue.push([fn, callback]);\n  }\n};\n\nMockBucket.prototype._isValidKey = function(key) {\n  return typeof key === 'string' || key instanceof Buffer;\n};\n\nMockBucket.prototype._checkHashkeyOption = function(options) {\n  if (options.hashkey !== undefined) {\n    if (!this._isValidKey(options.hashkey)) {\n      throw new TypeError('hashkey option needs to be a string or buffer.');\n    }\n  }\n};\n\nMockBucket.prototype._checkExpiryOption = function(options) {\n  if (options.expiry !== undefined) {\n    if (typeof options.expiry !== 'number' || options.expiry < 0) {\n      throw new TypeError('expiry option needs to be 0 or a positive integer.');\n    }\n  }\n};\n\nMockBucket.prototype._checkCasOption = function(options) {\n  if (options.cas !== undefined) {\n    if (typeof options.cas !== 'object' && typeof options.cas !== 'string') {\n      throw new TypeError('cas option needs to be a CAS object or string.');\n    }\n  }\n};\n\nMockBucket.prototype._checkDuraOptions = function(options) {\n  if (options.persist_to !== undefined) {\n    if (typeof options.persist_to !== 'number' ||\n      options.persist_to < 0 || options.persist_to > 8) {\n      throw new TypeError(\n        'persist_to option needs to be an integer between 0 and 8.');\n    }\n  }\n  if (options.replicate_to !== undefined) {\n    if (typeof options.replicate_to !== 'number' ||\n      options.replicate_to < 0 || options.replicate_to > 8) {\n      throw new TypeError(\n        'replicate_to option needs to be an integer between 0 and 8.');\n    }\n  }\n};\n\nMockBucket.prototype.get = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    var decValue = this._decodeDoc({value:origItem.value,flags:origItem.flags});\n    if (origItem.lockExpiry && origItem.lockExpiry > new Date()) {\n      // If the key is locked, the server actually responds with a -1 cas value\n      //   which is considered special, here we just make a fake cas.\n      callback(null, {\n        value: decValue,\n        cas: _createCas()\n      });\n    } else {\n      callback(null, {\n        value: decValue,\n        cas: origItem.cas\n      });\n    }\n  }, callback);\n};\n\nMockBucket.prototype.getMulti = function(keys, callback) {\n  if (!Array.isArray(keys) || keys.length === 0) {\n    throw new TypeError('First argument needs to be an array of non-zero length.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Second argument needs to be a callback.');\n  }\n\n  var self = this;\n  var outMap = {};\n  var resCount = 0;\n  var errCount = 0;\n  function getSingle(key) {\n    self.get(key, function(err, res) {\n      resCount++;\n      if (err) {\n        errCount++;\n        outMap[key] = { error: err };\n      } else {\n        outMap[key] = res;\n      }\n      if (resCount === keys.length) {\n        return callback(errCount, outMap);\n      }\n    });\n  }\n  for (var i = 0; i < keys.length; ++i) {\n    getSingle(keys[i]);\n  }\n};\n\nMockBucket.prototype.getAndTouch = function(key, expiry, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (typeof key !== 'string' && !(key instanceof Buffer)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof expiry !== 'number' || expiry < 0) {\n    throw new TypeError('Second argument needs to be 0 or a positive integer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    if (origItem.lockExpiry && origItem.lockExpiry > new Date()) {\n      return callback(new CbError(\n          'temporary error - key locked', errs.temporaryError), null);\n    }\n    origItem.expiry = _makeExpiryDate(expiry);\n    var decValue = this._decodeDoc({value:origItem.value,flags:origItem.flags});\n    callback(null, {\n      value: decValue,\n      cas: origItem.cas\n    });\n  }, callback);\n};\n\nMockBucket.prototype.getAndLock = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  if (options.lockTime !== undefined) {\n    if (typeof options.lockTime !== 'number' || options.lockTime < 1) {\n      throw new TypeError('lockTime option needs to be a positive integer.');\n    }\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    if (origItem.lockExpiry && origItem.lockExpiry > new Date()) {\n      return callback(new CbError(\n          'temporary error - key locked', errs.temporaryError), null);\n    }\n    if (options.lockTime) {\n      origItem.lockExpiry = _makeLockDate(options.lockTime);\n    } else {\n      origItem.lockExpiry = _makeLockDate(15);\n    }\n    origItem.cas = _createCas();\n    var decValue = this._decodeDoc({value:origItem.value,flags:origItem.flags});\n    callback(null, {\n      value: decValue,\n      cas: origItem.cas\n    });\n  }, callback);\n};\n\nMockBucket.prototype.getReplica = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n  if (typeof key !== 'string' && !(key instanceof Buffer)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  if (options.hashkey !== undefined) {\n    if (!this._isValidKey(options.hashkey)) {\n      throw new TypeError('hashkey option needs to be a string or buffer.');\n    }\n  }\n  this._checkHashkeyOption(options);\n\n  /* istanbul ignore next */\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    var decValue = this._decodeDoc({value:origItem.value,flags:origItem.flags});\n    callback(null, {\n      value: decValue,\n      cas: origItem.cas\n    });\n  }, callback);\n};\n\nMockBucket.prototype.touch = function(key, expiry, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof expiry !== 'number' || expiry < 0) {\n    throw new TypeError('Second argument needs to be 0 or a positive integer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkCasOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    if (origItem.lockExpiry && origItem.lockExpiry > new Date()) {\n      return callback(new CbError(\n          'temporary error - key locked', errs.temporaryError), null);\n    }\n    origItem.expiry = _makeExpiryDate(expiry);\n    callback(null, {\n      cas: origItem.cas\n    });\n  }, callback);\n};\n\nMockBucket.prototype.unlock = function(key, cas, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n  if (typeof key !== 'string' && !(key instanceof Buffer)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof cas !== 'object') {\n    throw new TypeError('Second argument needs to be a CAS object.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    if (!_compareCas(origItem.cas, cas)) {\n      return callback(new CbError(\n          'cas does not match', errs.keyAlreadyExists), null);\n    }\n    if (!origItem.lockExpiry || origItem.lockExpiry <= new Date()) {\n      return callback(new CbError(\n          'key not locked', errs.temporaryError), null);\n    }\n    origItem.lockExpiry = null;\n    callback(null, {\n      cas: origItem.cas\n    });\n  }, callback);\n};\n\nMockBucket.prototype.remove = function(key, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[1];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Second argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Third argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkCasOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n\n    var origItem = this.storage.get(key, options.hashkey);\n    if (!origItem) {\n      return callback(new CbError('key not found', errs.keyNotFound), null);\n    }\n    if (origItem.lockExpiry && origItem.lockExpiry > new Date()) {\n      return callback(new CbError(\n          'temporary error - key locked', errs.temporaryError), null);\n    }\n    var delCas = this.storage.remove(key, options.hashkey);\n    callback(null, {\n      cas: delCas\n    });\n  }, callback);\n};\n\nMockBucket.prototype._store = function(key, value, options, callback, opType) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (value === undefined) {\n    throw new TypeError('Second argument must not be undefined.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  this._checkHashkeyOption(options);\n  this._checkExpiryOption(options);\n  this._checkCasOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(function() {\n    /*\n    The following is intentionally verbose and repeated to make it\n    easier to see test-coverage of different paths that would occur\n    on the server.\n     */\n    if (opType === 'set') {\n      if (!options.hashkey) {\n        options.hashkey = key;\n      }\n      var origSetItem = this.storage.get(key, options.hashkey);\n      if (origSetItem && origSetItem.lockExpiry &&\n          origSetItem.lockExpiry > new Date() && !options.cas) {\n        return callback(new CbError(\n            'temporary error - key locked', errs.temporaryError), null);\n      }\n      if (origSetItem && !_compareCas(origSetItem.cas, options.cas)) {\n        return callback(new CbError(\n            'cas mismatch', errs.keyAlreadyExists), null);\n      }\n\n      var encItemSet = this._encodeDoc(value);\n      var newSetItem = {\n        value: encItemSet.value,\n        flags: encItemSet.flags,\n        expiry: _makeExpiryDate(options.expiry),\n        cas: _createCas()\n      };\n      this.storage.set(key, options.hashkey, newSetItem);\n      callback(null, {cas: newSetItem.cas});\n    } else if (opType === 'add') {\n      if (!options.hashkey) {\n        options.hashkey = key;\n      }\n      var origAddItem = this.storage.get(key, options.hashkey);\n      if (origAddItem) {\n        return callback(new CbError(\n            'key already exists', errs.keyAlreadyExists), null);\n      }\n\n      var encItemAdd = this._encodeDoc(value);\n      var newAddItem = {\n        value: encItemAdd.value,\n        flags: encItemAdd.flags,\n        expiry: _makeExpiryDate(options.expiry),\n        cas: _createCas()\n      };\n      this.storage.set(key, options.hashkey, newAddItem);\n      callback(null, {cas: newAddItem.cas});\n    } else if (opType === 'replace') {\n      if (!options.hashkey) {\n        options.hashkey = key;\n      }\n      var origReplaceItem = this.storage.get(key, options.hashkey);\n      if (!origReplaceItem) {\n        return callback(new CbError(\n            'key does not exist', errs.keyNotFound), null);\n      }\n      if (origReplaceItem.lockExpiry && origReplaceItem.lockExpiry > new Date() && !options.cas) {\n        return callback(new CbError(\n            'temporary error - key locked', errs.temporaryError), null);\n      }\n\n      if (origReplaceItem && !_compareCas(origReplaceItem.cas, options.cas)) {\n        return callback(new CbError(\n            'cas mismatch', errs.keyAlreadyExists), null);\n      }\n\n      var encItemReplace = this._encodeDoc(value);\n      var newReplaceItem = {\n        value: encItemReplace.value,\n        flags: encItemReplace.flags,\n        expiry: _makeExpiryDate(options.expiry),\n        cas: _createCas()\n      };\n      this.storage.set(key, options.hashkey, newReplaceItem);\n      callback(null, {cas: newReplaceItem.cas});\n    } else if (opType === 'append') {\n      if (!options.hashkey) {\n        options.hashkey = key;\n      }\n      var origAppendItem = this.storage.get(key, options.hashkey);\n      if (!origAppendItem) {\n        return callback(new CbError(\n            'key does not exist', errs.keyNotFound), null);\n      }\n      if (origAppendItem.lockExpiry && origAppendItem.lockExpiry > new Date()) {\n        return callback(new CbError(\n            'temporary error - key locked', errs.temporaryError), null);\n      }\n\n      var encValAppend = this._encodeDoc(value);\n      origAppendItem.value = Buffer.concat([\n          origAppendItem.value, encValAppend.value]);\n      origAppendItem.cas = _createCas();\n\n      callback(null, {\n        cas: origAppendItem.cas\n      });\n    } else if (opType === 'prepend') {\n      if (!options.hashkey) {\n        options.hashkey = key;\n      }\n      var origPrependItem = this.storage.get(key, options.hashkey);\n      if (!origPrependItem) {\n        return callback(new CbError(\n            'key does not exist', errs.keyNotFound), null);\n      }\n      if (origPrependItem.lockExpiry && origPrependItem.lockExpiry > new Date()) {\n        return callback(new CbError(\n            'temporary error - key locked', errs.temporaryError), null);\n      }\n\n      var encValPrepend = this._encodeDoc(value);\n      origPrependItem.value = Buffer.concat([\n        encValPrepend.value, origPrependItem.value]);\n      origPrependItem.cas = _createCas();\n\n      callback(null, {\n        cas: origPrependItem.cas\n      });\n    }\n  }, callback);\n};\n\nMockBucket.prototype.upsert = function(key, value, options, callback) {\n  this._store(key, value, options, callback, 'set');\n};\n\nMockBucket.prototype.insert = function(key, value, options, callback) {\n  this._store(key, value, options, callback, 'add');\n};\n\nMockBucket.prototype.replace = function(key, value, options, callback) {\n  this._store(key, value, options, callback, 'replace');\n};\n\nMockBucket.prototype.append = function(key, fragment, options, callback) {\n  this._store(key, fragment, options, callback, 'append');\n};\n\nMockBucket.prototype.prepend = function(key, fragment, options, callback) {\n  this._store(key, fragment, options, callback, 'prepend');\n};\n\nMockBucket.prototype.counter = function(key, delta, options, callback) {\n  if (options instanceof Function) {\n    callback = arguments[2];\n    options = {};\n  }\n\n  if (!this._isValidKey(key)) {\n    throw new TypeError('First argument needs to be a string or buffer.');\n  }\n  if (typeof delta !== 'number' || delta === 0) {\n    throw new TypeError('Second argument must be a non-zero integer.');\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError('Third argument needs to be an object or callback.');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('Fourth argument needs to be a callback.');\n  }\n  if (options.initial) {\n    if (typeof options.initial !== 'number' || options.initial < 0) {\n      throw new TypeError('initial option must be 0 or a positive integer.');\n    }\n  }\n  this._checkHashkeyOption(options);\n  this._checkExpiryOption(options);\n  this._checkDuraOptions(options);\n\n  this._maybeInvoke(function() {\n    if (!options.hashkey) {\n      options.hashkey = key;\n    }\n    var origCountItem = this.storage.get(key, options.hashkey);\n    if (options.initial !== undefined && !origCountItem) {\n      var newCountItem = {\n        value: new Buffer(options.initial.toString(), 'utf8'),\n        flags: 0,\n        cas: _createCas()\n      };\n      this.storage.set(key, options.hashkey, newCountItem);\n      return callback(null, {\n        value: options.initial,\n        cas: newCountItem.cas\n      });\n    }\n    if (!origCountItem) {\n      return callback(new CbError(\n          'key does not exist', errs.keyNotFound), null);\n    }\n    if (origCountItem.lockExpiry && origCountItem.lockExpiry > new Date()) {\n      return callback(new CbError(\n          'temporary error - key locked', errs.temporaryError), null);\n    }\n\n    var strValue = origCountItem.value.toString('utf8');\n    var numValue = parseInt(strValue, 10);\n    numValue += delta;\n    origCountItem.value = new Buffer(numValue.toString(), 'utf8');\n    origCountItem.cas = _createCas();\n\n    callback(null, {\n      value: numValue,\n      cas: origCountItem.cas\n    });\n  }, callback);\n};\n\nMockBucket.prototype.query = function(query, params, callback) {\n  if (params instanceof Function) {\n    callback = arguments[1];\n    params = undefined;\n  }\n\n  if (query instanceof ViewQuery) {\n    return this._view(query.ddoc, query.name, query.options, callback);\n  } else if (query instanceof SpatialQuery) {\n    throw new Error('Spatial queries are not supported in the mock.');\n  } else if (query instanceof N1qlQuery) {\n    throw new Error('N1QL queries are not supported in the mock.');\n  } else {\n    throw new TypeError(\n        'First argument needs to be a ViewQuery, SpatialQuery or N1qlQuery.');\n  }\n};\n\nObject.defineProperty(MockBucket.prototype, 'lcbVersion', {\n  get: function() {\n    return '0.0.0';\n  },\n  writeable: false\n});\n\nObject.defineProperty(MockBucket.prototype, 'clientVersion', {\n  get: function() {\n    return MOCK_VERSION;\n  },\n  writeable: false\n});\n\nfunction ViewQueryResponse(req) {\n}\nutil.inherits(ViewQueryResponse, events.EventEmitter);\n\nMockBucket.prototype._view = function(ddoc, name, q, callback) {\n  var req = new ViewQueryResponse();\n\n  var self = this;\n  process.nextTick(function() {\n    self._execView(ddoc, name, q, function(err, rows, meta) {\n      if (err) {\n        return req.emit('error', err);\n      }\n      for (var i = 0; i < rows.length; ++i) {\n        req.emit('row', rows[i]);\n      }\n      req.emit('rows', rows, meta);\n      req.emit('end', meta);\n    });\n  });\n\n  if (callback) {\n    req.on('rows', function(rows, meta) {\n      callback(null, rows, meta);\n    });\n    req.on('error', function(err) {\n      callback(err, null, null);\n    });\n  }\n  return req;\n};\n\nMockBucket.prototype._indexView = function(ddoc, name, options, callback) {\n  var ddocObj = this.ddocs[ddoc];\n  if (!ddocObj) {\n    return callback(new Error('not_found'));\n  }\n  if (ddocObj.views) {\n    ddocObj = ddocObj.views;\n  }\n  var viewObj = ddocObj[name];\n  if (!viewObj) {\n    return callback(new Error('not_found'));\n  }\n  var viewMapFunc = viewObj.map;\n\n  var retvals = [];\n\n  var curdocval = null;\n  var curdockey = null;\n  var curdocmeta = null;\n\n  function dateToArray (date) {\n    date = date.getUTCDate ? date : new Date(date);\n    return isFinite(date.valueOf()) ?\n      [date.getUTCFullYear(),\n      (date.getUTCMonth() + 1),\n      date.getUTCDate(),\n      date.getUTCHours(),\n      date.getUTCMinutes(),\n      date.getUTCSeconds()] : null;\n  }\n\n  function emit(key, val) {\n    var row = {\n      key: key,\n      id: curdockey,\n      value: val,\n      doc: {\n        meta: curdocmeta\n      }\n    };\n    if (curdocmeta.type === 'json') {\n      row.doc.json = curdocval;\n    } else {\n      row.doc.base64 = curdocval;\n    }\n    retvals.push(row);\n  }\n\n  var procOne = function(doc,meta){};\n  eval('procOne = ' + viewMapFunc);\n\n  for (var keyName in this.storage.items) {\n    if (this.storage.items.hasOwnProperty(keyName)) {\n      var thisKey = this.storage.items[keyName];\n      for (var hashKey in thisKey) {\n        if (thisKey.hasOwnProperty(hashKey)) {\n          var thisVal = thisKey[hashKey];\n\n          curdockey = keyName;\n\n          curdocval = null;\n          try {\n            curdocval = JSON.parse(thisVal.value.toString());\n          } catch (e) {\n          }\n\n          var curdoctype = curdocval ? 'json' : 'base64';\n          if (!curdocval) {\n            curdocval = thisVal.value.toString('base64');\n          }\n\n          curdocmeta = {\n            id: curdockey,\n            rev: '?NOTVALIDFORMOCK?',\n            expiration: thisVal.expiry ? thisVal.expiry : 0,\n            flags: thisVal.flags,\n            type: curdoctype\n          };\n\n          procOne(curdocval, curdocmeta);\n        }\n      }\n    }\n  }\n\n  var reducer = viewObj.reduce;\n  if (reducer) {\n    if (reducer === '_count') {\n      reducer = function(key, values, rereduce) {\n        if (rereduce) {\n          var result = 0;\n          for (var i = 0; i < values.length; i++) {\n            result += values[i];\n          }\n          return result;\n        } else {\n          return values.length;\n        }\n      };\n    } else if (reducer === '_sum') {\n      reducer = function(key, values, rereduce) {\n        var sum = 0;\n        for(var i = 0; i < values.length; i++) {\n          sum = sum + values[i];\n        }\n        return(sum);\n      };\n    } else if (reducer === '_stats') {\n      reducer = function(key, values, rereduce) {\n        return null;\n      };\n    } else {\n      eval('reducer = ' + reducer);\n    }\n  }\n\n  callback(null, retvals, reducer);\n};\n\n// http://docs.couchdb.org/en/latest/couchapp/views/collation.html\nvar SORT_ORDER = function() {\n  var ordered_array = [\n    'null',\n    'false',\n    'true',\n    'number',\n    'string',\n    'array',\n    'object',\n    'unknown'\n  ];\n\n  var obj = {};\n  for (var i = 0; i < ordered_array.length; i++) {\n    obj[ordered_array[i]] = i;\n  }\n  return obj;\n}();\n\n/**\n * Returns the sorting priority for a given type\n * @param v The value whose type should be evaluated\n * @return The numeric sorting index\n */\nfunction getSortIndex(v) {\n  if (typeof v === 'string') {\n    return SORT_ORDER['string'];\n  } else if (typeof v === 'number') {\n    return SORT_ORDER['number'];\n  } else if (Array.isArray(v)) {\n    return SORT_ORDER['array'];\n  } else if (v === true) {\n    return SORT_ORDER['true'];\n  } else if (v === false) {\n    return SORT_ORDER['false'];\n  } else if (v === null) {\n    return SORT_ORDER['null'];\n  } else if (typeof v === 'object') {\n    return SORT_ORDER['object'];\n  } else {\n    return SORT_ORDER['unknown'];\n  }\n}\n\n/**\n * Compares one value with another\n * @param a The first value\n * @param b The second value\n * @param [exact] If both @c b and @c b are arrays, setting this parameter to true\n * ensures that they will only be equal if their length matches and their\n * contents match. If this value is false (the default), then only the common\n * subset of elements are evaluated\n *\n * @return {number} greater than 0 if @c a is bigger than @b; a number less\n * than 0 if @a is less than @b, or 0 if they are equal\n */\nfunction cbCompare(a, b, exact) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (exact === true) {\n      if (a.length !== b.length) {\n        return a.length > b.length ? +1 : -1;\n      }\n    }\n    var maxLength = a.length > b.length ? b.length : a.length;\n    for (var i = 0; i < maxLength; ++i) {\n      var subCmp = cbCompare(a[i], b[i], true);\n      if (subCmp !== 0) {\n        return subCmp;\n      }\n    }\n    return 0;\n  }\n\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a.localeCompare(b);\n  }\n\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n\n  // Now we need to do special things\n  var aPriority = getSortIndex(a);\n  var bPriority = getSortIndex(b);\n  if (aPriority !== bPriority) {\n    return aPriority - bPriority;\n  } else {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}\n\n/**\n * Find the index of @c val in the array @arr\n * @param arr The array to search in\n * @param val The value to search for\n * @return {number} the index in the array, or -1 if the item does not exist\n */\nfunction cbIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; ++i) {\n    if (cbCompare(arr[i], val, true) === 0) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Normalize a key for reduce\n * @param key The key to normalize\n * @param groupLevel The group level\n * @return {*}\n */\nfunction cbNormKey(key, groupLevel) {\n  if (groupLevel === 0) {\n    return null;\n  }\n\n  if (Array.isArray(key)) {\n    if (groupLevel === -1) {\n      return key;\n    } else {\n      return key.slice(0, groupLevel);\n    }\n  } else {\n    return key;\n  }\n}\n\nMockBucket.prototype._execView = function(ddoc, name, options, callback) {\n  this._indexView(ddoc, name, options, function(err, results, reducer) {\n    if (err) {\n      return callback(err);\n    }\n\n    // Store total emitted rows\n    var rowcount = results.length;\n\n    // Parse if needed\n    var startkey = options.startkey ? JSON.parse(options.startkey) : undefined;\n    var startkey_docid = options.startkey_docid;\n    var endkey = options.endkey ? JSON.parse(options.endkey) : undefined;\n    var endkey_docid = options.endkey_docid;\n    var group_level = options.group_level || 0;\n\n    var inclusive_start = true;\n    var inclusive_end = true;\n    if (options.inclusive_end !== undefined) {\n      inclusive_end = options.inclusive_end;\n    }\n\n    // Invert if descending\n    if (options.descending) {\n      var _startkey = startkey;\n      startkey = endkey;\n      endkey = _startkey;\n      var _startkey_docid = startkey_docid;\n      startkey_docid = endkey_docid;\n      endkey_docid = _startkey_docid;\n      var _inclusive_start = inclusive_start;\n      inclusive_start = inclusive_end;\n      inclusive_end = _inclusive_start;\n    }\n\n    var key = options.key ? JSON.parse(options.key) : undefined;\n    var keys = options.keys ? JSON.parse(options.keys) : undefined;\n\n    var newResults = [];\n    for (var i = 0; i < results.length; ++i) {\n      var dockey = results[i].key;\n      var docid = results[i].id;\n\n      if (key !== undefined) {\n        if (cbCompare(dockey, key) !== 0) {\n          continue;\n        }\n      }\n      if (keys !== undefined) {\n        if (cbIndexOf(keys, dockey) < 0) {\n          continue;\n        }\n      }\n\n      if (inclusive_start) {\n        if (startkey && cbCompare(dockey, startkey) < 0) {\n          continue;\n        }\n        if (startkey_docid && cbCompare(docid, startkey_docid) < 0) {\n          continue;\n        }\n      } else {\n        if (startkey && cbCompare(dockey, startkey) <= 0) {\n          continue;\n        }\n        if (startkey_docid && cbCompare(docid, startkey_docid) <= 0) {\n          continue;\n        }\n      }\n\n      if (inclusive_end) {\n        if (endkey && cbCompare(dockey, endkey) > 0) {\n          continue;\n        }\n        if (endkey_docid && cbCompare(docid, endkey_docid) > 0) {\n          continue;\n        }\n      } else {\n        if (endkey && cbCompare(dockey, endkey) >= 0) {\n          continue;\n        }\n        if (endkey_docid && cbCompare(docid, endkey_docid) >= 0) {\n          continue;\n        }\n      }\n\n      if (!options.include_docs) {\n        delete results[i].doc;\n      }\n\n      newResults.push(results[i]);\n    }\n    results = newResults;\n\n    if (options.descending) {\n      results.sort(function(a,b){\n        var compare = cbCompare(b.key, a.key);\n        if (compare != 0) { return compare; }\n        if (a.id > b.id) { return -1; }\n        if (a.id < b.id) { return +1; }\n        return 0;\n      });\n    } else {\n      results.sort(function(a,b){\n        var compare = cbCompare(a.key, b.key);\n        if (compare != 0) { return compare; }\n        if (b.id > a.id) { return -1; }\n        if (b.id < a.id) { return +1; }\n        return 0;\n      });\n    }\n\n    if (options.skip && typeof options.skip !== 'number')\n      return callback(new Error('query_parse_error: Invalid value for integer parameter: \"' + options.skip.toString() + '\"'));\n    if (options.limit && typeof options.limit !== 'number')\n      return callback(new Error('query_parse_error: Invalid value for integer parameter: \"' + options.limit.toString() + '\"'));\n\n    if (options.skip && options.limit) {\n      results = results.slice(options.skip, options.skip + options.limit);\n    } else if (options.skip) {\n      results = results.slice(options.skip);\n    } else if (options.limit) {\n      results = results.slice(0, options.limit);\n    }\n\n    // Reduce Time!!\n    if (reducer && options.reduce !== false) {\n      var keys = [];\n      for (var i = 0; i < results.length; ++i) {\n        var keyN = cbNormKey(results[i].key, group_level);\n        if (cbIndexOf(keys, keyN) < 0) {\n          keys.push(keyN);\n        }\n      }\n\n      var newResults = [];\n      for (var j = 0; j < keys.length; ++j) {\n        var values = [];\n        for (var k = 0; k < results.length; ++k) {\n          var keyN = cbNormKey(results[k].key, group_level);\n          if (cbCompare(keyN, keys[j]) === 0) {\n            values.push(results[k].value);\n          }\n        }\n        var result = reducer(keys[j], values, false);\n        newResults.push({\n          key: keys[j],\n          value: result\n        });\n      }\n      results = newResults;\n    }\n\n    var meta = {\n      total_rows: rowcount\n    };\n\n    callback(null, results, meta);\n  });\n};\n\nmodule.exports = MockBucket;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mock/bucketmgr.js":"'use strict';\n\nfunction BucketManager(bucket) {\n  this._bucket = bucket;\n}\n\nBucketManager.prototype.getDesignDocuments = function(callback) {\n  var self = this;\n  process.nextTick(function() {\n    callback(null, self._bucket.ddocs);\n  });\n};\n\nBucketManager.prototype.insertDesignDocument = function(name, data, callback) {\n  var self = this;\n  this.getDesignDocument(name, function(err, res) {\n    if (!err) {\n      return callback(new Error('design document already exists'), null);\n    }\n    self.upsertDesignDocument(name, data, callback);\n  });\n};\n\nBucketManager.prototype.upsertDesignDocument = function(name, data, callback) {\n  var self = this;\n  process.nextTick(function() {\n    var newViews = {};\n\n    for (var viewType in data) {\n      if (data.hasOwnProperty(viewType)) {\n        if (viewType !== 'views') {\n          // Silently ignore spatial views\n          continue;\n        }\n\n        var newViewsT = {};\n        newViews[viewType] = newViewsT;\n\n        var mrList = data[viewType];\n        for (var viewName in mrList) {\n          if (mrList.hasOwnProperty(viewName)) {\n            newViewsT[viewName] = {};\n            if (!mrList[viewName].map) {\n              callback(new Error('invalid view data'), null);\n              return;\n            }\n            newViewsT[viewName].map = mrList[viewName].map.toString();\n            if (mrList[viewName].reduce) {\n              newViewsT[viewName].reduce = mrList[viewName].reduce.toString();\n            }\n          }\n        }\n      }\n    }\n    self._bucket.ddocs[name] = newViews;\n    callback(null, true);\n  });\n};\n\nBucketManager.prototype.getDesignDocument = function(name, callback) {\n  var self = this;\n  process.nextTick(function() {\n    var ddoc = self._bucket.ddocs[name];\n    if (!ddoc) {\n      callback(new Error('not_found'), null);\n      return;\n    }\n    var ddocs = {};\n    ddocs[name] = ddoc;\n    callback(null, ddocs);\n  });\n};\n\nBucketManager.prototype.removeDesignDocument = function(name, callback) {\n  var self = this;\n  process.nextTick(function() {\n    delete self._bucket.ddocs[name];\n    callback(null, true);\n  });\n};\n\nBucketManager.prototype.flush = function(callback) {\n  var self = this;\n  process.nextTick(function() {\n    self._bucket.storage.items = {};\n    callback(null, true);\n  });\n};\n\nmodule.exports = BucketManager;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mock/error.js":"'use strict';\n\nfunction CbError(message, code) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n  this.code = code;\n}\nCbError.prototype.__proto__ = Error.prototype;\n\nmodule.exports = CbError;\n","/home/travis/build/npmtest/node-npmtest-couchbase/node_modules/couchbase/lib/mock/clustermgr.js":"'use strict';\n\nfunction MockClusterManagement(cluster, username, password) {\n  this._cluster = cluster;\n  this._username = username;\n  this._password = password;\n}\n\nMockClusterManagement.prototype.listBuckets = function(callback) {\n  // TODO: Implement this\n  process.nextTick(function() {\n    callback(null, []);\n  });\n};\n\nmodule.exports = MockClusterManagement;\n"}